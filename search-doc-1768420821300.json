{"searchDocs":[{"title":"Comments","type":0,"sectionRef":"#","url":"/OPS102/bash/Comments","content":"Comments A comment in a bash script starts with a sharp symbol (#) and is ignored by the shell interpreter: # test script #1 # Written by Jason Bourne A comment may also be just one portion of a line: cd - # change to the user's previous working directory Note that a shbang line is a comment from the point of view of the shell interpreter -- it's there for the kernel to use, not the shell!","keywords":"","version":"Next"},{"title":"Arithmetic","type":0,"sectionRef":"#","url":"/OPS102/bash/arithmetic","content":"Arithmetic Bash can perform integer arithmetic. To evaluate an arithmetic expression and return a value, use $(( )): $ A=100 $ B=12 $ echo $((A*B)) 1200 $ echo $((B++)) 12 $ echo $B 13 Note that inside the double-parenthesis, spaces don't matter, and it is not necessary to use a dollar-sign [$] in front of variables being accessed. To evaluate an arithmetic expression without returning a value, use (( )): $ A=100 $ B=13 $ ((A++)) $ echo $A 101 $ ((C=A*B*2)) $ echo &quot;The answer is $C&quot; The answer is 2626 ","keywords":"","version":"Next"},{"title":"Command Capture","type":0,"sectionRef":"#","url":"/OPS102/bash/command-capture","content":"Command Capture You can capture the output (stdout) of a command as a string using the notation \\$( ) and then use that string in a variable assignment or as a command argument: $ echo &quot;The current date and time is: $(date)&quot; The current date and time is: Mon 19 Jun 2034 12:02:11 AM EDT $ FILES=&quot;$(ls|wc -l)&quot; $ echo &quot;There are $FILES files in the current directory $(pwd)&quot; There are 2938 files in the current directory /bin Avoid Backticks! You may see old scripts that use backticks (reverse single quotes) for command capture, like this: `` $ A=`ls` ` This is an archaic syntax which is depricated -- avoid doing this. Some fonts make it hard to distiguish between backticks and single-quotes, and nesting backticks is difficult.","keywords":"","version":"Next"},{"title":"Environment Variables","type":0,"sectionRef":"#","url":"/OPS102/bash/envars","content":"","keywords":"","version":"Next"},{"title":"Common Environment Variables​","type":1,"pageTitle":"Environment Variables","url":"/OPS102/bash/envars#common-environment-variables","content":" Environment Variable\tPurpose\tExamplesPS1\tNormal (first-level) shell prompt\tPS1=&quot;Enter command: &quot; PS1=&quot;[\\u@\\h \\W]$ &quot; EDITOR\tPath to the default text editor (typically /usr/bin/nano)\tEDITOR=/usr/bin/vi PATH\tA colon-separated list of directories that will be searched when looking for a command\tPATH=&quot;$PATH:.&quot; PATH=&quot;/usr/bin:/usr/sbin:.&quot; LANG\tThe default language -- used to select message translations as well as number, currency, date, and calendar formats.\tLANG=en_CA.UTF-8 LANG=fr_CA.UTF-8 HOME\tThe user's home directory - used for relative-to-home pathnames.\tHOME=/var/tmp RANDOM\tA random integer (0-32767)\t ","version":"Next","tagName":"h2"},{"title":"Exit Status Codes","type":0,"sectionRef":"#","url":"/OPS102/bash/exit","content":"Exit Status Codes When any process finishes executing, it exits with a numeric value. This can be called the exit code, status code, exit status code, or error code. Usually, an exit status code of zero (0) means that no errors were encountered, and a non-zero code means that something went wrong. Therefore, it may be easiest to think of this as the error code, with 0 meaning no errors. Be aware that program authors can use this value as they see fit, so the status code may indicate something else, such as the number of data items processed. The special variable $? is set to the exit status code of the last command executed by the shell. For example: $ ls -d /etc /etc $ echo $? 0 $ ls -d /this/does/not/exist ls: cannot access '/this/does/not/exist': No such file or directory $ echo $? 2 Why is this important? Because exit status codes are the key to conditional logic (if...) and looping (for/while/until/...) in bash scripting.","keywords":"","version":"Next"},{"title":"Bash Example Scripts","type":0,"sectionRef":"#","url":"/OPS102/bash/bash-examples","content":"","keywords":"","version":"Next"},{"title":"Computer Architecture​","type":1,"pageTitle":"Bash Example Scripts","url":"/OPS102/bash/bash-examples#computer-architecture","content":" This script displays a message based on the architecture of the computer:  #!/usr/bin/bash​ architecture=&quot;$(uname -m)&quot; # uname gets system information​ ​ if [[ &quot;$architecture&quot; == &quot;x86_64&quot; ]] then​ echo &quot;Your computer architecture is Intel/AMD x86_64.&quot;​ elif [[ &quot;$architecture&quot; == &quot;aarch64&quot; ]] then​ echo &quot;Your computer uses the 64-bit Arm architecture.&quot;​ else​ echo &quot;Your computer uses an unrecognized architecture.&quot;​ fi   ","version":"Next","tagName":"h2"},{"title":"Age Check​","type":1,"pageTitle":"Bash Example Scripts","url":"/OPS102/bash/bash-examples#age-check","content":" This script checks whether a customer is of legal drinking age in Ontario:  #!/usr/bin/bash​ read -p &quot;Enter the customer's date of birth: &quot; B​ ​ # Calculate the time in seconds that the customer turns/tuned 19​ D=&quot;$(date -d &quot;$B + 19 years&quot; +%s)&quot;​ ​ # Get the current time in seconds NOW=&quot;$(date +%s)&quot;​ # Tell the user if the customer is old enough to be served alcohol​ # This tests checks to see if the customer's 19th birthday is # less than (before) the current date. if [[ &quot;$D&quot; -lt &quot;$NOW&quot; ]] then​ echo &quot;The customer is of legal drinking age in Ontario.&quot;​ else​ echo &quot;The customer is too young to legally drink in Ontario.&quot;​ fi   ","version":"Next","tagName":"h2"},{"title":"Coinflip​","type":1,"pageTitle":"Bash Example Scripts","url":"/OPS102/bash/bash-examples#coinflip","content":" This script flips a virtual coin:  #!/usr/bin/bash​ COINFLIP=$((RANDOM % 2))​ # % is the modulus operator if [[ &quot;$COINFLIP&quot; == 0 ]] then​ echo &quot;Heads!&quot;​ else​ echo &quot;Tails&quot;​ fi   The COINFLIP variable is set to the remainder of the division of $RANDOM by 2. Therefore, it will have a random value of 0 or 1.  ","version":"Next","tagName":"h2"},{"title":"Cautious File Delete​","type":1,"pageTitle":"Bash Example Scripts","url":"/OPS102/bash/bash-examples#cautious-file-delete","content":" This script checks a file, provided as a positional argument (parameter), to ensure that it is a regular file and is writable, and then asks the user if they want to delete it. Note that this script uses the -f (file) test, -w (writeable) test, and combines a number of string tests with the || (OR) operator:  #!/usr/bin/bash​ if `[`&quot;$#&quot; -ne 1`](&quot;$#&quot;_-ne_1 &quot;wikilink&quot;)\\ then echo &quot;$(basename $0): Error: one filename argument must be provided.&quot; &gt;&amp;2 exit 1 fi F=&quot;$1&quot; # Put the first (and only!) argument value into the variable F if [[ ! -f &quot;$F&quot; ]​] then​ echo &quot;The filename '$F' does not refer to a regular file - skipping.&quot;​ elif [[ ! -w &quot;$F&quot; ]​] then​ echo &quot;The file '$F' is not writeable (by you) - skipping.&quot;​ else​ read -p &quot;Delete the regular file '$F'? (Y/N): &quot; YESNO​ if [[ &quot;$YESNO&quot; == &quot;Y&quot; || &quot;$YESNO&quot; == &quot;y&quot; || &quot;$YESNO&quot; == &quot;Yes&quot; ​ || &quot;$YESNO&quot; == &quot;yes&quot; || &quot;$YESNO&quot; == &quot;YES&quot; ]]​ then​ echo &quot;Deleting the file '$F'...&quot;​ rm &quot;$F&quot; # We should add some code to check if the rm succeeds or fails​ echo &quot;...done.&quot;​ else​ echo &quot;Skipping the file '$F' as requested.&quot;​ fi​ fi  ","version":"Next","tagName":"h2"},{"title":"Conditional Logic: if / then / elif / else / fi","type":0,"sectionRef":"#","url":"/OPS102/bash/if","content":"Conditional Logic: if / then / elif / else / fi Bash provides an if command to support conditional logic: if LIST1 then LIST2 fi If the command or commands in LIST1 execute successfully and return an exit status code of 0, then the commands in LIST2 are executed. For example, you could use a grep command as LIST1 and an echo command as LIST2: if grep -q &quot;OPS102&quot; courses.txt then echo &quot;The course code 'OPS102' was found in the file.&quot; fi The if command also supports the else keyword: if grep -q &quot;OPS102&quot; courses.txt then echo &quot;The course code 'OPS102' was found in the file.&quot; else echo &quot;The course code 'OPS102' was NOT found in the file.&quot; fi It also supports the elif (else-if) keyword: if grep -q &quot;OPS102&quot; courses.txt then echo &quot;The course code 'OPS102' was found in the file.&quot; elif grep -q &quot;ULI101&quot; courses.txt then echo &quot;The course code 'ULI101' was found in the file. else echo &quot;Neither 'OPS102' nor 'ULI101' was found in the file.&quot; fi Putting this all together, you could have a script like this: #!/usr/bin/bash read -p &quot;Enter a filename: &quot; FILE if grep -q &quot;OPS102&quot; &quot;$FILE&quot; then echo &quot;The course code 'OPS102' was found in the file $FILE.&quot; elif grep -q &quot;ULI101&quot; courses.txt then echo &quot;The course code 'ULI101' was found in the file $FILE. else echo &quot;Neither 'OPS102' nor 'ULI101' was found in the file $FILE.&quot; fi ","keywords":"","version":"Next"},{"title":"Parameters","type":0,"sectionRef":"#","url":"/OPS102/bash/param","content":"Parameters Arguments to a script are called parameters. You can access the parameters using the special variables $0, $1, $2, and so forth. $0 contains the name of the script, $1 contains the first parameter, $2 contains the second parameter, and so forth. The special variable $# contains the total number of parameters. Here is a simple script which shows you what parameters have been received: #!/usr/bin/bash​ echo &quot;Number of parameters: $#&quot;​ echo &quot;Parameter 0: $0&quot;​ echo &quot;Parameter 1: $1&quot;​ echo &quot;Parameter 2: $2&quot;​ echo &quot;Parameter 3: $3&quot;​ echo &quot;Parameter 4: $4&quot; When you run this script with three parameters (red, green, and blue), you get this output: $ ./params red green blue​ Number of parameters: 3​ Parameter 0: ./params Parameter 1: red​ Parameter 2: green​ Parameter 3: blue​ Parameter 4: The shift command discards parameter $1 and moves each of the remaining parameters to the previous position (so the value in parameter $2 is moved to $1, and $3 is moved to $2). We can modify the previous script to demonstrate this: $ cat params2​ #!/usr/bin/bash​ echo &quot;Number of parameters: $#&quot;​ echo &quot;Parameter 0: $0&quot;​ echo &quot;Parameter 1: $1&quot;​ echo &quot;Parameter 2: $2&quot;​ echo &quot;Parameter 3: $3&quot;​ echo &quot;Parameter 4: $4&quot; echo &quot;---- Performing shift ----&quot; shift echo &quot;Parameter 0: $0&quot;​ echo &quot;Parameter 1: $1&quot;​ echo &quot;Parameter 2: $2&quot;​ echo &quot;Parameter 3: $3&quot;​ echo &quot;Parameter 4: $4&quot; $ ./params2 red green blue Number of parameters: 3 Parameter 0: ./params2 Parameter 1: red Parameter 2: green Parameter 3: blue Parameter 4: ---- Performing shift ---- Parameter 0: ./params2 Parameter 1: green Parameter 2: blue Parameter 3: Parameter 4: The shift command is useful for looping through parameters, and for accessing parameters higher than number 9.","keywords":"","version":"Next"},{"title":"The test Command","type":0,"sectionRef":"#","url":"/OPS102/bash/test","content":"","keywords":"","version":"Next"},{"title":"Available Tests​","type":1,"pageTitle":"The test Command","url":"/OPS102/bash/test#available-tests","content":" There are four main types of tests available:  ","version":"Next","tagName":"h3"},{"title":"Tests Group 1: Filesystem Entries​","type":1,"pageTitle":"The test Command","url":"/OPS102/bash/test#tests-group-1-filesystem-entries","content":" These tests check a filename to see if it is a regular file, a directory, or a symbolic link:  [[ -f filename ]] # True if filename is a regular file [[ -d filename ]] # True if filename is a directory [[ -L filename ]] # True if filename is a symbolic link   Notes:  The -f and -d tests are lowercase, but the -L test is UPPERCASE. If a symbolic link points to a file, then both the -f and -L tests will succeed. If a symbolic link points to a directory, then both the -d and -L tests will succeed.  ","version":"Next","tagName":"h2"},{"title":"Tests Group 2: File Permissions​","type":1,"pageTitle":"The test Command","url":"/OPS102/bash/test#tests-group-2-file-permissions","content":" These tests check a filename to see if the person running the script can read, write, or execute the file (or access the directory):  [[ -r filename ]] # True if filename is readable [[ -w filename ]] # True if filename is writable [[ -x filename ]] # True if filename is executable   ","version":"Next","tagName":"h2"},{"title":"Tests Group 3: Strings​","type":1,"pageTitle":"The test Command","url":"/OPS102/bash/test#tests-group-3-strings","content":" These tests accept two string arguments, which are compared:  [[ string1 == string2 ]] # True if the strings are equal [[ string1 != string2 ]] # True if the strings are not equal [[ string1 &gt; string2 ]] # True if string1 sorts after string2 lexicographically [[ string1 &lt; string2 ]] # True if string1 sorts before string2 lexicographically   A note on the term lexicographically: Sorting lexicographically means sorting according to character code. This is like sorting alphabetically, but it applies to non-alphabetic characters as well, such as digits and punctuation marks. See the manpage for &quot;ascii&quot; to see the sequence of the first 128 character codes (or refer to a Unicode table for all of the character codes).  When sorting lexicographically, a comes before aa, which comes before b:  a aa b   In a similar way, 1 comes before 11, which comes before 2:  1 11 2   Note that this is different from numeric order, where 2 would preceed 11:  1 2 11   ","version":"Next","tagName":"h2"},{"title":"Test Group 4: Integers​","type":1,"pageTitle":"The test Command","url":"/OPS102/bash/test#test-group-4-integers","content":" These tests accept to integer arguments, which are compared:  [[ integer1 -eq integer2 ]] # Integers are equal [[ integer1 -ne integer2 ]] # Integers are not equal [[ integer1 -gt integer2 ]] # Integer1 is greater than integer2 [[ integer1 -ge integer2 ]] # Integer1 is greater than or equal to integer2 [[ integer1 -lt integer2 ]] # Integer1 is less than integer2 [[ integer1 -le integer2 ]] # Integer1 is less than or equal to integer2   ","version":"Next","tagName":"h2"},{"title":"Other Tests​","type":1,"pageTitle":"The test Command","url":"/OPS102/bash/test#other-tests","content":" The four groups of tests above will cover the vast majority of situations. There are additional tests available to test other conditions, such as whether a variable is defined, or a file refers to a device. See the man page for bash(1) for more information if you're interested in other tests: man bash  ","version":"Next","tagName":"h2"},{"title":"Negating and Combining Tests​","type":1,"pageTitle":"The test Command","url":"/OPS102/bash/test#negating-and-combining-tests","content":" The ! operator can be used to negate a test:  [[ ! -f &quot;$FILE&quot; ]] # True if &quot;$FILE&quot; is not a file (doesn't exist, or is a directory)   The AND operator &amp;&amp; combines tests, with the result being True if the tests on the left and right are both true:  [[ $A -lt $B &amp;&amp; $B -lt $C ]] # True if A is less than B, and also B is less than C.   The OR operator || combines tests, with the result being True if either of the tests are true:  [[ $A -lt 0 ]] # True if either: A is greater than B, or if A is less than 0.   You can use multiple !, &amp;&amp;, and || operators toegether:  [[ -f &quot;$FILE&quot; &amp;&amp; -r &quot;$FILE&quot; &amp;&amp; -w &quot;$FILE&quot; ]] # True if &quot;$FILE&quot; is a readable, writable regular file.   ","version":"Next","tagName":"h2"},{"title":"Tips on Using Tests​","type":1,"pageTitle":"The test Command","url":"/OPS102/bash/test#tips-on-using-tests","content":" Remember to quote any arguments which include whitespace, or which may be null (empty).Be careful with the &lt; and &gt; comparison operators: if you have a syntax error, you may accidentally redirect data (which in the case of&gt; might overwrite a file!) ","version":"Next","tagName":"h2"},{"title":"Reading Variable Values from Stdin: read","type":0,"sectionRef":"#","url":"/OPS102/bash/read","content":"Reading Variable Values from Stdin: read The read command reads a line of text from stdin and assigns it to the specified variable. For example, read A reads a line of text and assigns it to the variable A. The read command can also send a prompt to stdout using the -p option: $ read -p &quot;Enter your name: &quot; NAME Enter your name: Chris $ echo $NAME Chris Here is a script which uses a couple of read statements: #!/usr/bin/bash read -p &quot;Please enter your name: &quot; NAME echo &quot;Pleased to meet you, $NAME&quot; read -p &quot;Please enter a filename: &quot; FILE echo &quot;Saving your name into the file...&quot; echo &quot;NAME=$NAME&quot; &gt;&gt;$FILE echo &quot;Done.&quot; ","keywords":"","version":"Next"},{"title":"Basic Requirements for Shell Scripts","type":0,"sectionRef":"#","url":"/OPS102/bash/req","content":"Basic Requirements for Shell Scripts 1. Create a text file containing shell commands. Use any text editor (nano, vi, VS Code, gnome-text-editor, eclipse, ...) to create the file. 2. Tell the operating system which shell to use. Add a &quot;shbang&quot; line to the very top of the file, containing the text: #!/usr/bin/bash The first two chacters, the **sh**arp (#) and **bang** (!) give this line its name. They are recognized by the operating system kernel as identifying a script. The remainder of this line is interpreted by the kernel as the name of the shell which is to be used to interpret the script. In this case, /usr/bin/bash is the absolute path of the bash shell. You can substitute other interpreters to write scripts in other shell dialects (such as the Z-shell, /usr/bin/zsh) or languages (such as python, /usr/bin/python). Note that there must be nothing in font of the #! characters -- no space and no blank lines. 3. Ensure that the script has appropriate permissions. The kernel requires execute [x] permission, and the shell requires read [r] permission. Set this up with the chmod command (for example,chmod u+rx scriptname). Here is a simple example script using two commands, echo and date: #!/usr/bin/bash echo &quot;The current date and time is:&quot; date Notice the presence of the shbang line. If this is save into the file named &quot;now&quot;, the permission could be set with this command: $ chmod u+rx now The script can then be executed. Normally, the current working directory is not searched, so to run the a script in the current directory, you will need to explicitly specify the directory name like this: $ ./now The current date and time is: Sat Mar 6 12:03:32 EST 2038 ","keywords":"","version":"Next"},{"title":"Looping in Bash","type":0,"sectionRef":"#","url":"/OPS102/bash/loop","content":"","keywords":"","version":"Next"},{"title":"for VARIABLE in LIST​","type":1,"pageTitle":"Looping in Bash","url":"/OPS102/bash/loop#for-variable-in-list","content":" This type of loop iterates through a list of values; the VARIABLE is sequentially set to the each of the items in the list of values and the body of the loop is executed for each value. The list of values may be constants:  for X in 1 2 3 do ... body of the loop ... done   for COLOUR in red green blue do ... body of the loop ... done   Or the list may be the list of parameters (arguments to the script), written as &quot;$@&quot;:  for A in &quot;$@&quot; do ... body of the loop ... done   The most common use of this type of loop may be one or more globbing patterns (filename patterns with wildcard characters), which will be replaced with a list of all matching filenames:  for SOURCEFILE in *.c do ... body of the loop ... done   One thing to remember with this last form of the loop is that if the pattern does not match any file then the pattern itself will be assigned to the variable. For example, in the example above, if there are no files that match the pattern *.c then the variable SOURCEFILE will be set to the actual pattern: SOURCEFILE=*.c  This can be used in various ways. For example, this loop will compile all of the C source files found in the current directory:  for SOURCEFILE in *.c do echo &quot;=== Compiling $SOURCEFILE ===&quot; # This next line removes the extension from the filename BINARY=&quot;$(echo $SOURCEFILE | cut -d. -f1)&quot; gcc SOURCEFILE -o $BINARY done   (It's also possible to generate the LIST in other ways -- for example, from the output of another command, captured with $( ) )  ","version":"Next","tagName":"h2"},{"title":"The \"C-style\" for loop: for (( ; ; ))​","type":1,"pageTitle":"Looping in Bash","url":"/OPS102/bash/loop#the-c-style-for-loop-for----","content":" This loop is very similar to the &quot;for&quot; loop available in the C language. The C parenthesis are changed to bash double-parenthesis, to invoke the bash arithmetic syntax, and the curly-braces { } used in C are replaced by the bash do and done keywords. The three arguments in the double-parenthesis are the initial condition (variable initialization), the control condition (an expression that, while true, causes the loop to continue), and the increment/decrement (an expression which is executed at the end of each loop, which typically increments or decrements a counter).  For example, this loop counts from 1 to 10:  for (( i=0; i&lt;=10; i++ )) do echo $i done   ","version":"Next","tagName":"h2"},{"title":"while EXPR​","type":1,"pageTitle":"Looping in Bash","url":"/OPS102/bash/loop#while-expr","content":" This loop continues as long as the expression EXPR is true:  while [[ &quot;$A&quot; == &quot;$B&quot; ]] do ... body of the loop ... done   EXPR may be any single bash command, or a list of bash commands separated by newline characters (ENTER key) or semicolons, or a pipeline of commands. Most commonly it is a test [[ ]] command.  ","version":"Next","tagName":"h2"},{"title":"until EXPR​","type":1,"pageTitle":"Looping in Bash","url":"/OPS102/bash/loop#until-expr","content":" This loop continues as long as the expression EXPR is false:  until [[ &quot;$X&quot; -gt &quot;$Y&quot; ]] do ... body of the loop ... done   This loop will continue as long as $X is less than or equal to $Y -- as soon as the expression becomes true (when $X is greater than $Y), the loop will stop.  Examples  Here are a few bash scripting examples that include loops:  ","version":"Next","tagName":"h2"},{"title":"tput Colour Codes​","type":1,"pageTitle":"Looping in Bash","url":"/OPS102/bash/loop#tput-colour-codes","content":" The tput command outputs terminal codes to stdout to perform actions such as setting the text colour, clearing the screen, and so forth.  The tput setaf n and tput setab n commands set the foreground and background text colours, respectively. To see the available colours, this script can be used:  #!/usr/bin/bash for ((C=0; C&lt;16; C++)) do tput setaf $C # Set foreground to colour $C echo &quot;Colour $C&quot; done tput sgr0 # Reset to &quot;normal&quot; text mode   ","version":"Next","tagName":"h2"},{"title":"Number-Guessing Game​","type":1,"pageTitle":"Looping in Bash","url":"/OPS102/bash/loop#number-guessing-game","content":" This is the main example from the lecture. Study this code and ensure that you understand what it does (tip: test it, and alter it to see what effect your changes have):  #!/usr/bin/bash MAX=100 # Maximum value of secret MAX_TRIES=7 # Maximum number of tries (guesses) GAMES=0 # How many games have been played WINS=0 # How many games the user has won clear # Clear the screen tput setaf 5 # Select purple text echo &quot;=== Number-Guessing Game ===&quot; echo echo &quot;I have a secret number between 1 and $MAX&quot; echo &quot;Your mission is to guess it in as few tries as possible.&quot; echo &quot;You have a maximum of $MAX_TRIES guesses to succeed.&quot; echo PLAY=&quot;Y&quot; # This next loop continues until the user says # they don't want to play again while [[ &quot;$PLAY&quot; == &quot;Y&quot; || &quot;$PLAY&quot; == &quot;y&quot; || &quot;$PLAY&quot; == &quot;YES&quot; || &quot;$PLAY&quot; == &quot;Yes&quot; || &quot;$PLAY&quot; == &quot;yes&quot; ]] do # Generate a random number from 1-MAX SECRET=$(( RANDOM % MAX + 1 )) # Un-comment this line when debugging! # echo &quot;NOTE: the secret number is $SECRET&quot; GUESS=0 TRIES=0 ((GAMES++)) # This next loop continues until the user guess correctly # or the maximum number of guesses is exhausted until `[`| $TRIES -ge $MAX_TRIES `]($GUESS_-eq_$SECRET &quot;wikilink&quot;)\\ do tput setaf 15 # White text read -p &quot;Enter your guess (#$((++TRIES))): &quot; GUESS if `[`$GUESS -gt $SECRET`]($GUESS_-gt_$SECRET &quot;wikilink&quot;)\\ then tput setaf 1 # Red text echo &quot;Too high!&quot; elif `[`$GUESS -lt $SECRET`]($GUESS_-lt_$SECRET &quot;wikilink&quot;)\\ then tput setaf 1 # Red text echo &quot;Too low!&quot; else tput setaf 10 # Green text echo &quot;You got it in $((TRIES)) tries!&quot; ((WINS++)) fi echo done if `[`! $GUESS -eq $SECRET`](!_$GUESS_-eq_$SECRET &quot;wikilink&quot;)\\ then tput setaf 11 # Yellow text echo &quot;You lose after $TRIES attempts. The number was $SECRET. &quot; fi tput setaf 15 # White text echo read -p &quot;Do you want to play again (Y/N)? &quot; PLAY echo done tput setaf 5 # Purple text # In the next line, the multiplication # must preceed the division because # this is integer math echo &quot;You executed $GAMES missions and succeeded $WINS times ($((WINS*100/GAMES))% success).&quot; echo tput sgr0 # Reset to normal text  ","version":"Next","tagName":"h2"},{"title":"What is a script?","type":0,"sectionRef":"#","url":"/OPS102/bash/what","content":"What is a script? A shell script is a computer program which isinterpreted by an operating system shell. Scipts are used to automate procedures that could be manually performed from the command line. They can potentially save a huge amount of time by eliminating repetitive commands. For example, if you're going to compile and test a program 100x, and each compilation and test cycle requires 25 steps (commands), you're looking at performing 2500 steps. It's much more efficient to create a script containing those 25 steps and run it as needed -- in fact, you can even set things up so those commands execute automatically as soon as you save a new version of your program.","keywords":"","version":"Next"},{"title":"Arithmetic","type":0,"sectionRef":"#","url":"/OPS102/cmd/arithmetic","content":"Arithmetic CMD can perform integer arithmetic. To evaluate an arithmetic expressions and store the results in a variable, use the SET command with the /A (arithmetic) option. (Note: when used interactively the result of the expressions evaluation will be output to stdout; this does not happen inside scripts). &gt; SET A=100 &gt; SET B=12 &gt; SET /A X=A*B 1200 :: &lt;--- This does not get printed inside a script &gt; ECHO %X% 1200 &gt; SET /A A+=1 &gt; NUL: &gt; ECHO %A% 101 &gt; SET /A C=A*B*2 &gt; NUL: &gt; ECHO The answer is %C% The answer is 2424 Notes: You can perform more than one arithmetic evaluation and assignment in one SET command by separating the expressions with a comma [,]Some characters used in arithmetic expressions, such as the carat symbol, may need to be quoted or escaped to function correctly.​Percent signs, when used in arithmetic expressions (as the modulo operator), need to be doubled [%%] to avoid confusion with the percent signs placed around variable names​","keywords":"","version":"Next"},{"title":"A Basic CMD Script Example","type":0,"sectionRef":"#","url":"/OPS102/cmd/basic-script","content":"A Basic CMD Script Example Here is a simple example script using two commands, echo and date: @echo off echo The current date is: date /t The script can then be executed. Normally, the current working directory is not searched, so to run the a script in the current directory, you will need to explicitly specify the directory name like this: &gt; now The current date is: 2024-12-11 ","keywords":"","version":"Next"},{"title":"Command Echos​","type":0,"sectionRef":"#","url":"/OPS102/cmd/cmd-echo","content":"Command Echos​ Windows defaults to displaying each command in a script before executing it (the opposite of the default in the bash shell). If you do not wanteach command to be displayed, you can:​ Add an @ sign in front of each command, or​Issue the echo off command.​ Usually, you'll combine these in a script, using this as one of thefirst lines:​ @echo off​ ","keywords":"","version":"Next"},{"title":"Basic Requirements for Shell Scripts","type":0,"sectionRef":"#","url":"/OPS102/cmd/basic","content":"Basic Requirements for Shell Scripts Remember these requirements? They apply to Windows scripts too: 1. Create a text file containing shell commands.​ Use any text editor, such as Notepad, to create the file. 2. Tell the operating system which shell to use to execute the commands. In Windows, the filename extension is used to associate a file with a program, and this mechanism is used to associate a scriptwith a command interpreter.​ ​ For CMD scripts, the extension &quot;.cmd&quot; is used.​ For historical reasons, the extension &quot;.bat&quot; is also accepted.​For PowerShell scripts, the extension &quot;.ps1&quot; is used.​ The reason that &quot;.ps&quot; isn't used is that that extension was already used for PostScript files.​ (As a reminder: We're not going to write PowerShell scripts in this course).​ 3. Ensure that the script file has the appropriate permissions.​On Windows, the ability to read the script file is sufficient (and this is the default permission, so no change is usually required for scripts that you create for your own use; the situation may be different for scripts that are shared to other machines over the network or to otherusers on your system).​","keywords":"","version":"Next"},{"title":"Variables","type":0,"sectionRef":"#","url":"/OPS102/bash/Variables","content":"","keywords":"","version":"Next"},{"title":"Setting a Variable​","type":1,"pageTitle":"Variables","url":"/OPS102/bash/Variables#setting-a-variable","content":" To set a variable, simply type the variable name, an equal sign, and the variable value:  A=5 B=World TheNameOfTheUser=Jason   If the variable does not exist, it will be created. If it does exist, the previous value will be discarded.  Variable names may contain letters, digits, or underscores, but must not start with a digit.  Unlike some computer languages such as C, variables do not need to be declared. Variables are not typed -- they may be used as strings, integers, or decimal values.  Note that there must not be a space on either side of the equal sign.  ","version":"Next","tagName":"h2"},{"title":"Accessing a Variable​","type":1,"pageTitle":"Variables","url":"/OPS102/bash/Variables#accessing-a-variable","content":" To access a variable, place a dollar sign [$] in front of it, and use it in a command as an argument (or as a command name):  $ B=World $ echo $B World $ echo Hello $B Hello World   ","version":"Next","tagName":"h2"},{"title":"Quoting​","type":1,"pageTitle":"Variables","url":"/OPS102/bash/Variables#quoting","content":" ","version":"Next","tagName":"h2"},{"title":"Word Splitting and Quoting​","type":1,"pageTitle":"Variables","url":"/OPS102/bash/Variables#word-splitting-and-quoting","content":" Spaces and tabs are used to split a bash command line into individual &quot;words&quot;. This means that if you use an argument that contains a space, it will be treated as two separate arguments:  $ mkdir test $ cd test # this is new so it will be empty $ touch new file $ ls -l total 0 -rw------- 1 chris.tyler users 0 Mar 6 12:12 file -rw------- 1 chris.tyler users 0 Mar 6 12:12 new   Notice that touch new file created two files, because new and filewere treated as separate arguments.  To prevent word splitting, quote the text.  $ mkdir test $ cd test # this directory is new so it will be empty $ touch &quot;new file&quot; $ ls -l total 0 -rw------- 1 chris.tyler users 0 Mar 6 12:15 new file   Notice that only one file was created by the command touch \\&quot;new file\\&quot; because the quotes prevented word splitting, and the single argument new file was used as a single filename.  You'll also need to use quoting when assigning a string variable value containing a space:  $ A=&quot;Seneca Polytechnic&quot;   You can quote text with single-quotes ['] or double-quotes [&quot;]. Variable expansion takes place inside double quotes (this is calledinterpolation), but not inside single quotes:  $ B=World $ echo &quot;Hello $B&quot; # notice that $B is replaced with the value of B Hello World $ echo 'Hello $B' # notice that $B used as-in Hello $B   You should always double-quote variables that may contain a space in their value when using them as command arguments. This is especially true for filenames -- you never know when a user is going to put a space in a filename! Many scripts work find with opaque filenames (those containing no whitespace) but fail with non-opaque names.  Here is an example -- the difference between the first ls statement (which does not double-quote the variable) and the second ls statement (where the variable expansion is double-quoted):  $ touch &quot;red maple&quot; $ FILE=&quot;red maple&quot; $ ls $FILE ls: cannot access 'red': No such file or directory ls: cannot access 'maple': No such file or directory $ ls &quot;$FILE&quot; 'red maple'   ","version":"Next","tagName":"h3"},{"title":"Backslashes​","type":1,"pageTitle":"Variables","url":"/OPS102/bash/Variables#backslashes","content":" A backslash [\\] character outside of quotes or inside double quotes instructs the shell to ignore any special meaning that the following character may have. Examples:  $ touch &quot;new file&quot; $ ls -l new\\ file # The space loses its special meaning as an argument separator -rw-r--r--. 1 chris chris 0 Jun 18 22:49 'new file' $ echo &quot;This string contains a \\&quot;quoted\\&quot; string&quot; This string contains a &quot;quoted&quot; string $ A=Testing $ echo &quot; \\$A&quot; # The dollar sign loses its special meaning $A  ","version":"Next","tagName":"h3"},{"title":"Conditional Logic: IF/ELSE","type":0,"sectionRef":"#","url":"/OPS102/cmd/if-else","content":"","keywords":"","version":"Next"},{"title":"Available Tests​","type":1,"pageTitle":"Conditional Logic: IF/ELSE","url":"/OPS102/cmd/if-else#available-tests","content":" There are four main types of tests available:  ","version":"Next","tagName":"h3"},{"title":"Tests Group 1: Filesystem Entries​","type":1,"pageTitle":"Conditional Logic: IF/ELSE","url":"/OPS102/cmd/if-else#tests-group-1-filesystem-entries","content":" Tests that a filename exists (regardless of the entry type: file or directory):  EXIST filename   ","version":"Next","tagName":"h2"},{"title":"Tests Group 2: String Equality​","type":1,"pageTitle":"Conditional Logic: IF/ELSE","url":"/OPS102/cmd/if-else#tests-group-2-string-equality","content":" Test for string equality:  string1 == string2   ","version":"Next","tagName":"h2"},{"title":"Tests Group 3: String and Numeric Comparisons​","type":1,"pageTitle":"Conditional Logic: IF/ELSE","url":"/OPS102/cmd/if-else#tests-group-3-string-and-numeric-comparisons","content":" These tests accept two string arguments, both strings or both integers, which are compared. Adding the /i switch will make string comparisonscase-insensitive (UPPER/lowercase).​  value1 EQU value2 True if the values are equal​ value1 NEQ value2 True if the values are not equal​ value1 LSS value2 True if the value1 less than value2 ​ value1 LEQ value2 True if the value1 less/equal to value2​ value1 GTR value2 True if the value1 greater than value2​ value1 GEQ value2 True if the value1 greater than or equal to to value2​   To force a string comparison, enclose value1 and value2 in quotes. Otherwise, the shell will determine if the variables appear to contain integer values and compare them as integers, or otherwise compare them as strings.  ","version":"Next","tagName":"h2"},{"title":"Tests Group 4: Variable Definition, Errorlevel​","type":1,"pageTitle":"Conditional Logic: IF/ELSE","url":"/OPS102/cmd/if-else#tests-group-4-variable-definition-errorlevel","content":" Test to see if a variable is defined​: ​  DEFINED variable True if variable is defined​   Test to see if the ERRORLEVEL is above a threshold​:  ERRORLEVEL value True if ERORRLEVEL&gt;=value​   Although it's probably better to just an integer comparison such as:%ERRORLEVEL% GEQ value​  ","version":"Next","tagName":"h2"},{"title":"Notes about IF and these Tests​","type":1,"pageTitle":"Conditional Logic: IF/ELSE","url":"/OPS102/cmd/if-else#notes-about-if-and-these-tests","content":" These tests work only with the IF commandThe IF command can be used with GOTO and a label:  IF test GOTO :skip​ ...​ :skip​   Note that using a GOTO in a loop will make the shell forget about theloop, regardless of where the label is located!​  ","version":"Next","tagName":"h2"},{"title":"Negating and Combining Tests​","type":1,"pageTitle":"Conditional Logic: IF/ELSE","url":"/OPS102/cmd/if-else#negating-and-combining-tests","content":" You can negate (invert) a test with the NOT operator:  IF NOT EXIST %N% ECHO The file %N% does not exist.   Note that you cannot combine tests - there is no AND or OR operator -- but you can nest tests (which is similar to using AND). ","version":"Next","tagName":"h2"},{"title":"Script Parameters","type":0,"sectionRef":"#","url":"/OPS102/cmd/param","content":"Script Parameters Arguments to a script are called parameters. You can access the parameters using the special variables %0, %1, %2, and so forth.%0 contains the name of the script, %1 contains the first parameter,%2 contains the second parameter, and so forth. (Note that there is no second percent sign after the parameter number!) The shift command gets rid of the first parameter and shifts everyparameter to a lower number.​ Examples: &gt; type params.cmd​ @echo off​ ECHO PARAM 0: %0​ ECHO PARAM 1: %1​ ECHO PARAM 2: %2​ &gt; params red green blue​ PARAM 0: params​ PARAM 1: red​ PARAM 2: green​ &gt; type params-shift.cmd​ @echo off​ ECHO List of all arguments: %*​ :start​ IF &quot;%1&quot;==&quot;&quot; GOTO :done​ ECHO %1​ SHIFT​ GOTO :start​ :done​ &gt; params-shift yellow orange red​ List of all arguments: yellow orange red​ yellow​ orange​ red The special variable %* returns all of the parameters. On the command line, parameters may be separated by: Space (or Tab)Comma [,]Semicolon [;]Equal sign [=]","keywords":"","version":"Next"},{"title":"Environment Variables","type":0,"sectionRef":"#","url":"/OPS102/cmd/envars","content":"","keywords":"","version":"Next"},{"title":"Common Environment Variables​","type":1,"pageTitle":"Environment Variables","url":"/OPS102/cmd/envars#common-environment-variables","content":" Environment Variable\tPurpose\tExamplesCD\tCurrent directory\t''ECHO %CD%'' TIME\tCurrent time (HH:MM:SS)\t''ECHO %TIME%'' DATE\tCurrent date in local format\t''ECHO %DATE%'' ERRORLEVEL\tThe error code / exit status of the last command executed (note that some commands or programs do not set this variable as expected).\t''DIR \\FileThatDoesNotExist ''\\ ''ECHO %ERRORLEVEL%'' PATH\tA semicolon [;] separated list of directories that will be searched when looking for a command\t''PATH=&quot;$PATH;\\SpecialDirectory&quot;'' PROMPT\tThe prompt presented by the shell.\t''SET PROMPT=Enter a command: ''\\ ''SET PROMPT=PPPG '' RANDOM\tA random integer (0-32767)\tECHO %RANDOM%  Note that the prompt and path programs may also be used to adjust the PROMPT and PATH environment variables, respectively. ","version":"Next","tagName":"h2"},{"title":"Windows vs. Linux Scripting","type":0,"sectionRef":"#","url":"/OPS102/cmd/cmd-vs-bash","content":"","keywords":"","version":"Next"},{"title":"An Abundance of Shells​","type":1,"pageTitle":"Windows vs. Linux Scripting","url":"/OPS102/cmd/cmd-vs-bash#an-abundance-of-shells","content":" We've looked at scripting on Linux systems using the bash shell -- which is the most widely-deployed shell on Linux and other Unix-likesystems. There are many other shells on similar systems, including:​  sh – the original Unix shell (&quot;Bourne Shell&quot;), written by Steven Bourne​ksh – the Korn shell, written by David Korn​csh – the C shell, which has a C-like syntax​fish – the Friendly Interactive shell​Zsh – the Z shell, similar to ksh​  Many of these have a syntax based on and similar to the original Bourne shell, which is standardized in the POSIX.1 standard (or IEEE Standard1003.1), and these shells have a lot in common.​  On Windows, there are two main shells:  CMD - The Windows command shell, which is the traditional Windows shell. Although based on traditional DOS command syntax, the CMD shell has beenconsiderably expanded, with many new features added over the last few years.​ PowerShell – this is a new Windows command shell, which combines scripting with object-oriented programming. It is pre-installed for interactive use on current Windows systems; however, the execution of PowerShell scripts is disabled by default on all Windows &quot;client&quot; (non-server) systems, includingSeneca lab computers.​  ​Due to PowerShell scripting being disabled by default, and because object oriented programming is not taught in the first semester programming courses, we will focus on scripting using the traditionalWindows CMD shell.​  ","version":"Next","tagName":"h2"},{"title":"Cross-Platform Scripting​","type":1,"pageTitle":"Windows vs. Linux Scripting","url":"/OPS102/cmd/cmd-vs-bash#cross-platform-scripting","content":" There are several possible approaches to writing scripts that will work on both Linux and Windows systems, as well as other common operatingsystems such as Mac OS:​  Bash or Zsh – bash is the default shell on most Linux systems, and zsh is the default shell on most Mac OS systems; either shell can be easily used on either system. Both shells are available as third-party add-ons for the Windows operating system, usually shipped with a collection of GNU utilities compiled for use with Windows (for example, see https:gitforwindows.org/)​ PowerShell – installed by default on current Windows systems, it is also available for Linux and Mac OS systems, although it is not commonly used on those systems yet (see https://github.com/PowerShell/PowerShelli )  ","version":"Next","tagName":"h2"},{"title":"Other Interpreted Languages​","type":1,"pageTitle":"Windows vs. Linux Scripting","url":"/OPS102/cmd/cmd-vs-bash#other-interpreted-languages","content":" In addition to shell scripting languages, there are other interpreted languages that are well suited for cross-platform development, includingPython and Perl.​  ​When should you use a shell scripting langauge?​  Shell scripting languages are ideally suited for process control –executing, managing, and combining external programs to accomplish tasks.​ Shell scripting languages are not well-suited for implementing advanced processing algorithms, because they generally lack features such as good floating-point support, typed variables, and strong support for largearrays and hashes.​  ","version":"Next","tagName":"h2"},{"title":"Windows \"Shell Scripts\" vs. Batch Files\"​","type":1,"pageTitle":"Windows vs. Linux Scripting","url":"/OPS102/cmd/cmd-vs-bash#windows-shell-scripts-vs-batch-files","content":" DOS and early Windows systems were inherently interactive in nature, and early scripts were called &quot;batch files&quot; because they were viewed assimilar to non-interactive batch processing on mainframe systems.​  This terminology has stuck, and Windows shell scripts are still often called &quot;batch files&quot; (hence the occasional use of the .bat extensioninstead of .cmd).​​  The concept of a &quot;batch file&quot; and a &quot;shell script&quot; are roughlyequivalent.​  ","version":"Next","tagName":"h2"},{"title":"Basic Requirements for Shell Scripts​","type":1,"pageTitle":"Windows vs. Linux Scripting","url":"/OPS102/cmd/cmd-vs-bash#basic-requirements-for-shell-scripts","content":" Remember these requirements? They apply to Windows scripts too:  1. Create a text file containing shell commands. Use any text editor, such as Notepad, to create the file.  2. Tell the operating system which shell to use to execute thecommands.​ In Windows, the filename extension is used to associate a file with a program, and this mechanism is used to associate a scriptwith a command interpreter.​ ​  For CMD scripts, the extension .cmd is used.​ For historical reasons, the extension .bat is also accepted.​ For PowerShell scripts, the extension .ps1 is used.​ The reason that.ps isn't used is that that extension was already used for PostScript files.​ (As a reminder: We're not going to write PowerShell scripts in this course).​  3. Ensure that the script file has the appropriate permissions.​On Windows, the ability to read the script file is sufficient (and this is the default permission, so no change is usually required for scripts that you create for your own use; the situation may be different for scripts that are shared to other machines over the network or to otherusers on your system).​  Command Echos​  Windows defaults to displaying each command in a script before executing it (the opposite of the default in the bash shell). If you do not wanteach command to be displayed, you can:​  Add an @ sign in front of each command, or​Issue the echo off command.​  Usually, you'll combine these in a script, using this as one of thefirst lines:​  @echo off​  ","version":"Next","tagName":"h2"},{"title":"Reading Variable Values from Stdin: SET /P","type":0,"sectionRef":"#","url":"/OPS102/cmd/set-stdin","content":"","keywords":"","version":"Next"},{"title":"Command Capture​","type":1,"pageTitle":"Reading Variable Values from Stdin: SET /P","url":"/OPS102/cmd/set-stdin#command-capture","content":" There is no direct equivalient to command capture, but it is possible to use SET /P with redirection from standard input using the less-than [&lt;] symbol to capture one line of text:  &gt; DATE /T &gt;X &gt; SET /P D= ``&lt;X &gt; ECHO %D% 2024-12-11  ","version":"Next","tagName":"h2"},{"title":"Looping","type":0,"sectionRef":"#","url":"/OPS102/cmd/loop","content":"","keywords":"","version":"Next"},{"title":"Delayed Expansion​","type":1,"pageTitle":"Looping","url":"/OPS102/cmd/loop#delayed-expansion","content":" When the body of a FOR loop is executed, the variables are expanded (replaced by their values) before the loop begins. That means that any variables that are contained in the loop have their values locked-in andthey can't be changed while the loop is executing.​  To allow updated variable values to be accessed within a loop:​  1. Set the EnableDelayedExpansion option:​  SETLOCAL EnableDelayedExpansion​   ​2. Change any variables which will be updated during the execution of the loop by replacing the percent-signs ( % ) with exclaimation-marks (! ):​  %ERRORLEVEL% -&gt; !ERRORLEVEL!​   ","version":"Next","tagName":"h2"},{"title":"Loop throush a List of Files or Parameters​","type":1,"pageTitle":"Looping","url":"/OPS102/cmd/loop#loop-throush-a-list-of-files-or-parameters","content":" To loop through a list of values such as filenames, use:  FOR %variable IN (files) DO list​   The variable will be sequentially set to each of the given filesvalues, and the loop body (list) will be executed once for each value.  The files value may be:  A list of filenames: FOR %F IN (file1.txt file2.pdf file3.c) DO ECHO %FA filename pattern: FOR %F IN (*.pdf) DO ECHO %FFixed strings: FOR %C IN (Red Green Blue) DO ECHO %COr a list of all of the parameters: FOR %P IN (%*) DO ECHO %P  The /D option can be used along with a filename pattern to match only directories:  FOR /D %variable IN (files) DO list   ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Looping","url":"/OPS102/cmd/loop#example","content":" @echo off​ SETLOCAL EnableDelayedExpansion​ FOR %%F IN (\\*) DO (​ rem The CHOICE command presents a Y/N choice and sets %ERRORLEVEL% rem to 1 if the user selected Y and 2 if the user selected N CHOICE /M &quot;DELETE %%F&quot;​ IF !ERRORLEVEL!==1 (​ ECHO ...Deleting %%F​ DEL %%F​ ) ELSE (​ ECHO ...Skipping %%F​ )​   ","version":"Next","tagName":"h3"},{"title":"Loop through a Range of Integers​","type":1,"pageTitle":"Looping","url":"/OPS102/cmd/loop#loop-through-a-range-of-integers","content":" FOR /L (start, step, end) DO list   This type of loop counts forward or backwards from start to end by a given step.  Example:​ ​  @echo off​ rem Count from 0 to 5 in increments of 1​ FOR /L %%I IN (0, 1, 5) DO ECHO ... %%I ...​ rem Count from 4 to 0 in increments of -1​ FOR /L %%I IN (4, -1, 0) DO ECHO ... %%I ...   Output:  0 1 2 3 4 5 &lt;- This is the end of output from the first loop, having gone from 0 to 5 4 &lt;- The second loop starts output here, going from 4 to 0 3 2 1 0  ","version":"Next","tagName":"h2"},{"title":"Variables","type":0,"sectionRef":"#","url":"/OPS102/cmd/var","content":"","keywords":"","version":"Next"},{"title":"Setting a Variable​","type":1,"pageTitle":"Variables","url":"/OPS102/cmd/var#setting-a-variable","content":" To set a variable, use the set keyword with a variable name, an equal sign, and the variable value:  set A=5 set B=World   If the variable does not exist, it will be created. If it does exist, the previous value will be discarded.  Variable names may contain letters, digits, or underscores, but must not start with a digit. Case does not matter! The variable names Number,number, and NUMBER all refer to the same variable.  Do not put spaces on either side of the equal sign.  Variables are not typed -- they may be used as strings, integers, or decimal values.  ","version":"Next","tagName":"h2"},{"title":"Accessing a Variable​","type":1,"pageTitle":"Variables","url":"/OPS102/cmd/var#accessing-a-variable","content":" To access a variable, place a percent sign [%] on either side of it, and use it in a command as an argument (or as a command name):  &gt; SET B=World &gt; echo %B% World &gt; echo Hello $B Hello World   ","version":"Next","tagName":"h2"},{"title":"Quoting​","type":1,"pageTitle":"Variables","url":"/OPS102/cmd/var#quoting","content":" ","version":"Next","tagName":"h2"},{"title":"Word Splitting and Quoting​","type":1,"pageTitle":"Variables","url":"/OPS102/cmd/var#word-splitting-and-quoting","content":" Quoting in the Windows shell is very different from Bash!  Using single or double quotes causes the quotes themselves to be included as part of the string or argument in most cases, but not whendealing with a filename:​  &gt; ECHO &quot;Hello&quot;​ &quot;Hello&quot;​ &gt; ECHO test &gt; &quot;test file&quot;​   ​Quoting is not required when assigning a string value which contains spaces to a variable:  &gt; SET A=One Two Three &gt; ECHO %A% One Two Three   ","version":"Next","tagName":"h3"},{"title":"Carat Symbols​","type":1,"pageTitle":"Variables","url":"/OPS102/cmd/var#carat-symbols","content":" Escaping characters to remove their special meaning is performed using the carat [^] symbol in Windows.​ In this example, the ampersand [&amp;] symbol would normally cause an error, but it can be treated as a regular character by escaping it with a carat:  &gt; echo Lost ^&amp; Found Lost &amp; Found   When piping, a CMD subshell is started for each command in the pipeline, and it is necessary to use triple carat symbols ^^^ to escapecharacters:​  &gt; echo Lost ^^^&amp; Found | find &quot;Lost&quot; ​ Lost &amp; Found ​  ","version":"Next","tagName":"h2"},{"title":"Root, Home, and Current Working Directories","type":0,"sectionRef":"#","url":"/OPS102/Filesystems/CWD","content":"","keywords":"","version":"Next"},{"title":"Root Directory​","type":1,"pageTitle":"Root, Home, and Current Working Directories","url":"/OPS102/Filesystems/CWD#root-directory","content":" The root directory is the main directory. All other directories and files are contained inside the root directory.  ","version":"Next","tagName":"h2"},{"title":"Current Working Directory (or Working Directory or Current Directory)​","type":1,"pageTitle":"Root, Home, and Current Working Directories","url":"/OPS102/Filesystems/CWD#current-working-directory-or-working-directory-or-current-directory","content":" Most operating systems have the concept of a current working directory (also called the current directory or working directory), which is a directory to be temporarily designated as the current working location. The working directory may be changed at any time.  To change the current working directory on Linux or on Windows, use the cd command (change directory) followed by a directory name:  cd ops102   To see the name of the current directory, use the command pwd (Print Working Directory) on Linux or cd (without a directory name) on Windows.  To change your current directory to your home directory on Linux, use the cd command by itself (with no arguments).  Tip: To quickly change back to the previous working directory on a Linux system, issue the command: cd -  ","version":"Next","tagName":"h2"},{"title":"Home Directory​","type":1,"pageTitle":"Root, Home, and Current Working Directories","url":"/OPS102/Filesystems/CWD#home-directory","content":" Both Windows and Linux create a directory for each user, which is used to store that user's personal files.  On a Linux system, the home directory is contained within a directory named home which is within the root directory. Each user's home directory name is their user ID; for example, the user jdoe would have the home directory /home/jdoe.  The directory named /home is not the home directory! The directory /home contains all of the users' home directories.  On a Windows system, the home directory is C:\\Users\\username. The user jdoe would have a home directory of C:\\Users\\jdoe.  ","version":"Next","tagName":"h2"},{"title":"A Word about MacOS Systems​","type":1,"pageTitle":"Root, Home, and Current Working Directories","url":"/OPS102/Filesystems/CWD#a-word-about-macos-systems","content":" On MacOS, home directories are stored in /Users rather than /home, but otherwise, MacOS and Linux filesystems are very similar. ","version":"Next","tagName":"h2"},{"title":"Basic Commands for Dealing with Files and Directories","type":0,"sectionRef":"#","url":"/OPS102/Filesystems/Basic-Commands","content":"Basic Commands for Dealing with Files and Directories Here are some basic commands for creating and removing files and directories, changing and displaying the current directory, and displaying a tree diagram of a directory hierarchy. We will look at other commands in future topics. Description\tLinux Command\tWindows Command\tNotesMake a Directory\tmkdir directory\tmkdir directory Remove a Directory (Must be empty)\trmdir directory\trmdir directory Change (Working) Directory\tcd directory\tcd directory Print Current Working Directory\tpwd\tcd Change to Home Directory\tcd List Contents of Directory\tls ls -l\tdir\tLinux: -l option displays long listing (including permissions, ownership, size, modification date/time) Create an Empty File\ttouch file\tcopy nul file Remove/Delete a File\trm file\tdel file Display a Tree Diagram starting at Current Directory\ttree\ttree tree /f\tWindows: /f causes tree to display files (otherwise only directories are shown) Copy a file\tcp sourcefile destinationfile\tcopy sourcefile destinationfile Move or rename a file\tmv currentfilename newfilename\tmove currentfilename newfilename Display the text contents of a file\tcat file\ttype file\tNote: Using these commands on a file that contains non-text data may look very strange.","keywords":"","version":"Next"},{"title":"Hierarchical File Systems","type":0,"sectionRef":"#","url":"/OPS102/Filesystems/Hierarchical-fs","content":"Hierarchical File Systems Most modern computers are equipped with one or more random-access storage devices — either a mechanical hard disk drive (HDD), or a fully electronic solid state disk (SSD). Both of these provide a numbered set of blocks or sectors, each of which stores a set amount of data (typically 512 or 1024 bytes). However, accessing storage as numbered blocks is very inconvenient for computer users! In order to conveniently use this storage, it is arranged into files, which are named collections of bytes of arbitrary length. The organization of blocks/sectors into files is handled by a filesystem, which is a scheme for structuring data, along with the corresponding software to implement this scheme. There are different types of filesystems, intended for different purposes. For example: the fat filesystem is widely used on USB flash drives and SD cards which may be connected to a wide range of different computer systems. It's a lightweight, simple filesystem that is good for exchanging data between different types of systems, but it doesn't have any advanced features such as file permissions (access control). the NTFS (Windows) and ext4 (Linux) filesystems are very different but offer similar capabilities. Windows and Linux use very different approaches to identifying users and controlling access to files, and these two filesystems are specifically designed to work with these different approaches - NTFS is designed to work with the Windows approach, and ext4 is designed to work with the Linux approach. the btrfs filesystem is a high-performance filesystem used on Linux systems. It provides advanced features useful for enterprise systems, such as storage pooling, error mitigation, snapshot backups, and integrity checking. Most filesystems track metadata about a file in addition to the file name (usually written as &quot;filename&quot;), such as the date/time of creation, the date/time of last modification, the owner or original creator of the file, and the permissions applicable to the file (for example, who is permitted to read and to change the file contents). A hierarchical filesystem introduces the concept of directories, which are special files which hold zero or more other files. The files in a directory may themselves be directories, enabling files to be nested into an arbitrary hierarchy. When graphical user interfaces were developed, the metaphor of a traditional paper-based office was introduced, and directories were called folders in this metaphor (a folder in a traditional office is a piece of card stock folded in half to group together related papers). Therefore, the terms directory and folder are synonyms — you can use them interchangeably in most contexts.","keywords":"","version":"Next"},{"title":"Filenames","type":0,"sectionRef":"#","url":"/OPS102/Filesystems/Filenames","content":"","keywords":"","version":"Next"},{"title":"Extensions​","type":1,"pageTitle":"Filenames","url":"/OPS102/Filesystems/Filenames#extensions","content":" Many operating systems use an extension at the end of a filename to denote the type of data stored in the file. These extensions are delimited by a period followed by one or more characters. For example, in the filename:  ops102_project.pdf   The extension is &quot;pdf&quot;, denoting a file in Portable Document Format.  It is unusual to use multiple extensions on a Windows system, but not uncommon on a Linux (or other Unix-like) system. For example, on a Linux system, the filename  backup.tar.gz   has two extensions, &quot;tar&quot; indicating a archive created with the tar command, and &quot;gz&quot; indiciating that the file was compressed with the gzip command.  ","version":"Next","tagName":"h2"},{"title":"Case Sensitivity​","type":1,"pageTitle":"Filenames","url":"/OPS102/Filesystems/Filenames#case-sensitivity","content":" Some filesystems are case-sensitive, and UPPER- and lower-case letters are considered to be different. For example, the filenames MILK.PDF, Milk.pdf, and milk.pdf refer to three different files. This is the case with most Linux (and Unix-like) filesystems.  Most Windows filesystems are not case-sensitive, so the filenames MILK.PDF, Milk.pdf, and milk.pdf would refer to the same file. ","version":"Next","tagName":"h2"},{"title":"Pathnames","type":0,"sectionRef":"#","url":"/OPS102/Filesystems/Pathnames","content":"","keywords":"","version":"Next"},{"title":"1. Absolute Pathnames​","type":1,"pageTitle":"Pathnames","url":"/OPS102/Filesystems/Pathnames#1-absolute-pathnames","content":" An absolute pathname starts with a slash (on Unix-based operating systems, such as Linux), or a backslash (on Windows), indicating the root directory. It contains the names of all of the directories from the root directory to the specified file, separated by slash/backslash characters.  For example, on a Linux system, the pathname  /home/kim/ops102/presentation.pdf   indicates that the file presentation.pdf can be found by starting at the root directory, then traversing to a directory named home containing the directory kim containing the directory ops102 containing the file presentation.pdf.  Similarly, the Windows pathname  \\Users\\kim\\ops102\\presentation.pdf   indicates that the file presentation.pdf can be found by starting at the root directory, then traversing to a directory named Users containing the directory kim containing the directory ops102 containing the file presentation.pdf.  Absolute pathnames can be readily identified by the fact that they start with the slash/backslash character. They are often the longest form of the pathname, but they are unambiguous.  ","version":"Next","tagName":"h2"},{"title":"2. Relative-to-Home Pathnames​","type":1,"pageTitle":"Pathnames","url":"/OPS102/Filesystems/Pathnames#2-relative-to-home-pathnames","content":" On Linux (and other Unix-like operating systems), pathnames may be specified starting with the tilde (~) character followed by a slash, which represents the current user's home directory. This is a directory assigned by the system administrator which contains all of the user's personal files. Remember that the home directory is usually (but not always) `/home/username  For example, if the current user's home directory is /home/kim, then the filename  ~/ops102/presentation.pdf   corresponds to the absolute pathname  /home/kim/ops102/presentation.pdf   For any file in the user's home directory, a relative-to-home pathname is generally shorter than an absolute pathanme. However, a relative-to-home pathname will have a different meaning for other users, since each user has a unique home directory.  You can also specify the user whose home directory is to be used as the starting point, by placing the a userid between the tilde and slash characters. Thus the pathanme  ~kim/ops102/presentation.pdf   is relative to the home directory of the user kim, regardless of which user is currently logged in, while the pathname  ~sam/ops102/presentation.pdf   is relative to the home directory of the user sam.  ","version":"Next","tagName":"h2"},{"title":"3. Relative Pathnames​","type":1,"pageTitle":"Pathnames","url":"/OPS102/Filesystems/Pathnames#3-relative-pathnames","content":" Any pathname that does not start with a slash/backslash or a tilde character is a relative pathname, which is interpreted as starting at the current directory.  If the current directory is /home/kim/ops102, then the Linux pathname  presentation.pdf   is interpreted as  /home/kim/ops102/presentation.pdf   The symbol .. means the parent directory, which is the directory which contains the current directory. Assuming the same current directory as above (/home/kim/ops102), the Linux pathname  ../Downloads/example.txt   Is interpreted as  /home/kim/Downloads/example.txt   In the same way, the symbol . is interpreted as referring to the current directory, so  ./test.odt   is the same as  test.odt   and both refer to  /home/kim/ops102/test.odt   Likewise, if the current directory on a Windows system was\\Users\\kim, then the pathaname  ops102\\presentation.pdf   refers to the absolute pathname  \\Users\\kim\\ops102\\presentation.pdf   And the relative pathname  ..\\jdoe\\Downloads\\example.txt   refers to the absolute pathname  \\Users\\jdoe\\Downloads\\example.txt   Relative pathnames are often the shortest form of pathname if the target file is in the current working directory or a subdirectory of the current working directory, but the meaning of a relative pathname changes based on the current working directory.  ","version":"Next","tagName":"h2"},{"title":"Directory vs File Names​","type":1,"pageTitle":"Pathnames","url":"/OPS102/Filesystems/Pathnames#directory-vs-file-names","content":" It is often impossible to tell whether a pathname refers to a file or to a directory. For example, the Linux pathname /home/chris/presentation might refer to a file named presentation or to a directory named presentation.  If you wish to explicitly indicate that a pathname refers to a directory, append a slash or backslash to the pathname.  ","version":"Next","tagName":"h2"},{"title":"Identifying Pathnames​","type":1,"pageTitle":"Pathnames","url":"/OPS102/Filesystems/Pathnames#identifying-pathnames","content":" You can easily identify the type of a pathname by examining the first symbol in the pathname:  Starting Symbol\tType of Pathname\tStarting Location\tExample (Linux)\tExample (Windows)slash / (Linux) or backslash \\ (Windows)\tAbsolute\tRoot directory\t/home/jdoe/readme.txt\t\\Users\\jdoe\\readme.txt tilde ~ (Linux)\tRelative-to-home\tHome directory\t~/readme.txt\tNot applicable any other symbol\tRelative\tCurrent working directory\treadme.txt ./readme.txt\treadme.txt .\\readme.txt  ","version":"Next","tagName":"h2"},{"title":"Converting Pathnames​","type":1,"pageTitle":"Pathnames","url":"/OPS102/Filesystems/Pathnames#converting-pathnames","content":" ","version":"Next","tagName":"h2"},{"title":"Relative to Absolute​","type":1,"pageTitle":"Pathnames","url":"/OPS102/Filesystems/Pathnames#relative-to-absolute","content":" To convert a relative pathname to an absolute pathname, prepend the current directory, using a slash (or backslash) as the separator.  For example, on Linux, you may have this situation:  Current working directory: /var/tmp Relative pathname: notes.pdf   To convert that relative pathname to an absolute pathname, simply prepend the current working directory to the relative pathname using / as the separator:  Absolute pathname: /var/tmp/notes.pdf   On Windows, the process is similar, but you will need to use a backslash as a separator:  Current working directory: \\Windows\\systemtemp Relative pathname: notes.pdf   To convert that pathname to an absolute pathname, just prepend the current working directory, using \\ as the separator:  Absolute pathname: \\Windows\\systemtemp\\notes.pdf   ","version":"Next","tagName":"h3"},{"title":"Relative-to-Home to Absolute​","type":1,"pageTitle":"Pathnames","url":"/OPS102/Filesystems/Pathnames#relative-to-home-to-absolute","content":" To convert a relative-to-home pathname (on Linux) to an absolute pathname, replace the home directory symbol (either ~ by itself, or ~username for a designated user's home directory):  Home directory (current user): /home/jdoe Relative-to-home pathname: ~/ops102/lab1/test   To perform this conversion, replace the ~ symbol with the home directory:  Absolute pathname: /home/jdoe/ops102/lab1/test   If a username is provided after the tilde:  Home directory (for the user &quot;kim&quot;): /home/kim Relative-to-home pathname: ~kim/ops102/lab1/test   In this case, replace ~kim with the home directory of the user named kim:  /home/kim/ops102/lab1/test  ","version":"Next","tagName":"h3"},{"title":"Components of an Operating System","type":0,"sectionRef":"#","url":"/OPS102/Introduction-to-OS/Components","content":"","keywords":"","version":"Next"},{"title":"The Kernel​","type":1,"pageTitle":"Components of an Operating System","url":"/OPS102/Introduction-to-OS/Components#the-kernel","content":" This is the heart of the operating system, the main program (or group of programs) that controls the computer. The kernel operates in a special privileged mode (such as &quot;Ring 0&quot; on Intel/AMD x86 processors, or &quot;Exception Level 3&quot; on ARM processors), which allows it to manage the resources and security settings for all other software. The kernel is loaded by the computer's firmware (built-in software) and sets up the computer's hardware and resources before starting the services and user interface(s) in non-privileged mode, controlling the computer's hardware to enforce the privilege level.  (You will occasionally see alternate spellings of kernel, such as &quot;kernal&quot;, in some operating systems - especially older ones. ).  ","version":"Next","tagName":"h2"},{"title":"System Libraries​","type":1,"pageTitle":"Components of an Operating System","url":"/OPS102/Introduction-to-OS/Components#system-libraries","content":" Many programs need to perform the same operations, such as accessing the network, playing sound, or drawing something on the screen. Libraries provide a common set of software procedures (also known as functions, methods, routines, or subroutines) which programs access to perform these common operations. This eliminates the need for each program to contain duplicate code for these common operations, which reduces software duplication and program size. Although additional libraries may be installed on the computer, the system libraries provided as part of the operating system provide the most broadly-used procedures required by nearly every program.  ","version":"Next","tagName":"h2"},{"title":"Services​","type":1,"pageTitle":"Components of an Operating System","url":"/OPS102/Introduction-to-OS/Components#services","content":" These are programs that run continuously in the background, providing services such as WiFi authentication, print management, and file sharing. Unlike the kernel, these programs don't operate with full system privilege, and are therefore subject to the same type of resource and security management as regular programs, and they also utilize the system libraries.  ","version":"Next","tagName":"h2"},{"title":"The User Interface(s)​","type":1,"pageTitle":"Components of an Operating System","url":"/OPS102/Introduction-to-OS/Components#the-user-interfaces","content":" This is the software that enables the user to interact with the system. Most operating systems provide at least two user interfaces:  1. A text-based user interface that enables the user to enter commands, view the output from those commands, and interact with full-screen text interfaces such as file editors and file managers. This may be referred to as a text user interface (TUI) or a command line interface (CLI). Here are command line interfaces on Windows, Linux, and Android systems displaying similar information:    2. A graphical user interface (GUI) that typically enables the user to interact with multiple application windows, using a keyboard and a pointing device such as a mouse, trackpad, or touchscreen. Here are graphical user interfaces on Windows and Linux systems showing similar capabilities and information:    ","version":"Next","tagName":"h2"},{"title":"Utilities and Applications​","type":1,"pageTitle":"Components of an Operating System","url":"/OPS102/Introduction-to-OS/Components#utilities-and-applications","content":" Most operating systems provide a set of tools to enable users to perform setup, configuration, and maintenance tasks. For example, they may provide &quot;utility&quot; software to add/remove software, configure hardware, and manage files. This utility software may take the form of commands that are accessed through a CLI, or graphical utilities that are accessed through a GUI. Most operating systems also provide a set of basic starter applications, such as a text editor, clock, a few games, and sometimes a web browser; the quantity and complexity of the included applications vary considerably from one operating system to another. ","version":"Next","tagName":"h2"},{"title":"Volume Designators","type":0,"sectionRef":"#","url":"/OPS102/Filesystems/Volume-Designators","content":"Volume Designators On Windows systems, a volume designator consisting of a letter followed by a colon may prefix a pathname. The volume may be a partition on a disk drive (HDD or SSD), a shortcut to a network storage location, or a multi-drive volume, where multiple partitions or disks are combined into a single storage pool. Since the original IBM PC was designed to have up to two floppy disk drives, designated A: and B:, the main/first disk drive in a Windows system is usually designated as volume C: Therefore, the \\Windows folder on the main/first disk drive on a Windows system may be referred to as C:\\Windows The volume designator is case-insensitive. Each unique volume on a Windows system has its own current/working directory. You can switch between volumes by typing the volume designator by itself. On a Linux system, instead of using drive designators, volumes are mounted into the filesystem hierarchy -- that is, volumes are attached as directories, creating a unified hierarchy with a single root directory.","keywords":"","version":"Next"},{"title":"Anatomy of a Command Line Interface (CLI)","type":0,"sectionRef":"#","url":"/OPS102/Introduction-to-OS/Anatomy-CLI","content":"Anatomy of a Command Line Interface (CLI) A CLI is provided by two programs: A terminal program, which is responsible for collecting user input and displaying the output from the shell and commands. A shell, which interprets the user's written commands. These may be on the same machine, or they may be on different computers. For example, it is common to access both Linux and Windows systems over a remote connection, using a protocol such as SSH (&quot;secure shell&quot;, which protects the connection using encryption). In that case, the terminal program runs on the computer in front of the user, and the shell runs on the remote computer system.","keywords":"","version":"Next"},{"title":"GUI vs CLI: Advantages and Disadvantages","type":0,"sectionRef":"#","url":"/OPS102/Introduction-to-OS/GUI-CLI","content":"","keywords":"","version":"Next"},{"title":"GUIs and CLIs are Complimentary​","type":1,"pageTitle":"GUI vs CLI: Advantages and Disadvantages","url":"/OPS102/Introduction-to-OS/GUI-CLI#guis-and-clis-are-complimentary","content":" Since computer programs are text, programmers become accustomed to referring to resources using text descriptions. For example, a programmer may write line of C code to open a file like this:   open(&quot;/usr/local/share/words&quot;, O_RDONLY);   If the programmer wanted to check on that file, perhaps to see the file size, they could use a either a GUI or a CLI tool. But since they've just been looking at text (the code they just wrote), it's often easiest to stay in the same mental mode and access the file using a CLI tool, rather than to switch to a different paradigm and use a GUI tool.  A programmer will often use both types of user interfaces in combination. For example, they may adjust a sound file using a GUI, then use a CLI to place the sound file into a particular folder or directory, mixing and matching GUI and CLI tools on-they-fly. ","version":"Next","tagName":"h2"},{"title":"A Brief History of Operating Systems","type":0,"sectionRef":"#","url":"/OPS102/Introduction-to-OS/History","content":"","keywords":"","version":"Next"},{"title":"The Impact of Operating System History​","type":1,"pageTitle":"A Brief History of Operating Systems","url":"/OPS102/Introduction-to-OS/History#the-impact-of-operating-system-history","content":" The impact of this lineage of operating systems is reflected in various conventions and design decisions present in the current versions of Linux and Windows.  For example, you will find many Windows commands that are completely different from Unix commands, because they were adopted from CP/M (via QDOS via DOS). You will also find some Windows commands that are identical to Unix commands, because they were directly incorporated from Xenix, such as mkdir and rmdir.  On the other hand, you'll find that Linux (and MacOS) commands are more closely related to Unix commands, because Linux and modern MacOS take their structure directly from Unix. ","version":"Next","tagName":"h2"},{"title":"What is an Operating System?","type":0,"sectionRef":"#","url":"/OPS102/Introduction-to-OS/What-is","content":"What is an Operating System? An operating system (OS) does exactly what the name states: It is software that operates a computer system! Not all computers have had or required an operating system. Particularly simple computers, including the earliest models of both business computers and microcomputers, as well as very simple embedded computers, do not require an operating system. The computer embedded into a simple mass-market microwave oven, for example, only ever runs one program, does not have communications capabilities, does not multitask, and is never updated, and therefore does not need an operating system. However, virtually all contemporary computer systems, including most online embedded devices, are sufficiently complex that they are equipped with an operating system.","keywords":"","version":"Next"},{"title":"What does an Operating System do?","type":0,"sectionRef":"#","url":"/OPS102/Introduction-to-OS/What-does","content":"","keywords":"","version":"Next"},{"title":"1. Management and Separation of Resources​","type":1,"pageTitle":"What does an Operating System do?","url":"/OPS102/Introduction-to-OS/What-does#1-management-and-separation-of-resources","content":" Think of the specifications that were advertised when you bought your last computer (or smartphone):  multiple CPU coresseveral gigabytes of RAM memorystorage in the gigabytes to terabytes rangea display with a particular resolutionvarious peripherals, such as cameras, speakers, and so forth  All of these are system resources. The operating system manages these resources to ensure that they are used effectively, and to ensure that there are no conflicts over their use.  As requested by the user(s), or as triggered by other factors such as the time of day or operational requirements, the OS will create processes -- running instances of computer programs. Each process is allocated compute resources by being permitted to run on one or more computer cores. To run a large number of processes, the OS will switch between them, stopping one process and starting another as needed to ensure that all of the processes get a fair share of system resources (which may not always be an equal share).  The operating system will allocate the available memory to processes and to the operating system's internal operations. The OS will program the system hardware to ensure that no process can overwrite memory allocated to another process.  The OS will also allocate storage space to various files as they are created and extended, and deallocate space when those files are truncated (shortened) or deleted. The space allocated to one file will be protected from use in other files.  Display space is similarly shared; the operating system will ensure that multiple programs can each display in their own windows, but prevent them from destroying graphics being displayed by other windows.  Peripheral devices are managed in different ways according to the characteristics of the device. For example, sound output from multiple processes will be combined for simultaneous output to the speakers (or other output devices). However, when a process accesses a printer, output from that processes is collected into a document, and the documents are queued for sequential printing, because simultaneous access would result in garbled output.  ","version":"Next","tagName":"h2"},{"title":"2. Security Enforcement​","type":1,"pageTitle":"What does an Operating System do?","url":"/OPS102/Introduction-to-OS/What-does#2-security-enforcement","content":" It's important to keep information private in some contexts, and to share information in other contexts. The operating system is responsible for enforcing security rules. For example, on a smartphone, a social media app shouldn't be able to access data from a banking app, and on a cloud server, one customer shouldn't be able to access another customer's data. However, multiple smartphone apps might be permitted to access a photo album, and a company employee might need to view a report generated on a server from multiple customers' data.  The operating system is responsible for enforcing the security rules but not for creating them -- the system administrators and/or users are responsible for creating and maintaining the security settings and policies which the operating system enforces.  ","version":"Next","tagName":"h2"},{"title":"3. Hardware Abstraction​","type":1,"pageTitle":"What does an Operating System do?","url":"/OPS102/Introduction-to-OS/What-does#3-hardware-abstraction","content":" There are many different types of devices that perform similar functions, and multiple ways that these devices can be connected. For example:  A keyboard may be connected via a USB connection or a wireless Bluetooth connection, or may be created as a virtual keyboard on a touchscreen.A mouse may be connected via a wired USB, wireless USB dongle, or wireless Bluetooth connection. But there are also other types of devices which can provide the same capability of allowing the user to interact with the display, including trackpads, trackballs, and touchscreens.Sound may be played over built-in speakers, an external analog speaker, an analog headset, a digital speaker or headset with a USB connection, a Bluetooth speaker, earbuds, or headset, or played through a television connected via HDMI.  The operating system abstracts away these hardware details. This means that programs can access devices in a general way without having to be programmed to individually deal with each type of device that may be used. This enables a program to request keyboard input or play sounds without regard to the details of the specific hardware available.  ","version":"Next","tagName":"h2"},{"title":"4. Maintaining the Programming Model​","type":1,"pageTitle":"What does an Operating System do?","url":"/OPS102/Introduction-to-OS/What-does#4-maintaining-the-programming-model","content":" The operating system, computer hardware, and development tools (compiler, linker, and so forth) work together to present the &quot;programming model&quot; -- a conceptual framework which software developers use when creating software.  As a simple example, several different application programs may be designed to occupy the same area of memory; obviously, this presents a conflict when these applications are used at the same time, so the operating system works with the computer's hardware to load the applications into different areas of physical memory, and then use the computer's virtual memory capabilities to make each program appear to be loaded into the region of memory for which it was written. ","version":"Next","tagName":"h2"},{"title":"Common Simple Commands","type":0,"sectionRef":"#","url":"/OPS102/Patterns/Common-Commands","content":"Common Simple Commands Here are some basic commands useful for managing the filesystem and performing basic tasks: Linux\tWindows\tDescriptionls\tdir\tLists the contents of a directory -- by default, the current directory, or the directories specified as arguments (or a specific file, if specified). echo\techo\tPlaces a message on the screen (the message is given as positional arguments) cal Displays a simple calendar date\tdate /t time /t\tTells you the current date (or date/time) who\tquser\tDisplays information about the logged in user(s) whoami\twhoami\tDisplays the name of the current user clear\tcls\tClears the screen (terminal). Note: in the Bash shell, you can also clear the screen during command entry by typing Ctrl+L tree\ttree\tDisplays a &quot;tree view&quot; of the filesystem hierarchy starting at the current directory (or the given directory, if an argument is provided). mkdir\tmkdir\tMake a directory/folder rmdir\trmdir\tRemove a directory/folder rm\tdel\tRemoves/deletes one or more files. Specify ''-rf'' to recursively force delete a directory and its contents on Linux, or ''/s'' to recursively delete a directory and its contents on Windows. X:\t(Where X is a drive letter) Switches to the selected drive. cd\tcd\tChanges to the given directory, if one is given. If no directory is given, displays the current directory (Windows) or changes to your home directory (Linux). On Windows, a drive designator may be provided, in which case the current directory will be set on the indicated drive. pwd\tcd\tPrints the current working directory. cp\tcopy\tCopy one or more files to a new name/location. mv\tmove\tMoves a file from one directory to another. mv\tren rename\tRenames a file (on Linux, the filename and location are considered to be the same thing) cat\ttype\tDumps the contents of a text file on the terminal (if there is a lot of text, the display will scroll; if the file is a non-text file, the results are undefined!) more less\tmore\tDisplays a file one screen at a time. (Linux: the less command is a more powerful version of the ''more'' command, which allows things like scrolling backwards) cut Selects specific columns from a text file sort\tsort\tSorts a text file diff\tcomp fc\tShows the differences between (text) files uniq Displays identical consequtive lines only once tr Translates/replaces/deletes occurrences of characters grep\tfind\tSearches files for text find Searches for files touch\tcopy NUL: //filename//\tCreates an empty file (Linux: if the file exists, ''touch'' will just update the date/time of modification).","keywords":"","version":"Next"},{"title":"Filename Patterns","type":0,"sectionRef":"#","url":"/OPS102/Patterns/Filename-Patterns","content":"","keywords":"","version":"Next"},{"title":"Wildcard Symbols​","type":1,"pageTitle":"Filename Patterns","url":"/OPS102/Patterns/Filename-Patterns#wildcard-symbols","content":" Symbol\tMeaning in Linux\tMeaning in Windows*\tMatches zero or more characters\tMatches zero or more characters ?\tMatches one character\tMatches one character, unless at the end of the filename or immediately before the dot preceeding the extension in which case it matches zero or one character [list] or [range]\tMatches any one of the characters within the brackets (note that it matches exactly one of the characters)\tNot applicable  ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"Filename Patterns","url":"/OPS102/Patterns/Filename-Patterns#examples","content":" Pattern\tMatches on Linux\tDoes not match on Linux\tMatches on Windows\tDoes not match on Windows*.html\tfirst.html blue.html\tRED.HTML purple.htm\tBlue.html blue.html RED.HTML\tpurple.htm a*\ta aa aaa alpha argonaut\tAlpha banana\ta aa aaa alpha Alpha\tbanana b*e\tblue bite\tred green blot\tblue bite\tred green blot c[oa]t\tcat cot\tcoat cat cot coat //(Not applicable)// d?e\tdue doe\tduo Doe date\tdue doe Doe\tduo date a??\taaa abc\taa abcd\taaa abc aa\tabcd  Therefore the command  del *.pdf   on Windows, or  rm *.pdf   on Linux will remove all files in the current directory that have the extension .pdf  You can combine absolute, relative, or relative-to-home pathnames with patterns. For example, in the command:   del \\Users\\jdoe\\Documents\\*.txt   the pattern \\\\Users\\\\jdoe\\\\Documents\\\\\\*.txt* will match all files with a txt extension in the \\\\Users\\\\jdoe\\\\Documents\\\\ directory, and thedel command will then attempt to delete all of the matching files.  On Linux, you can also use patterns to match directory names:   rm /home/chris/ops102/*/info.pdf   This will delete any files named info.pdf within any subdirectory of/home/chris/ops102/ ","version":"Next","tagName":"h2"},{"title":"Viewing Online Documentation","type":0,"sectionRef":"#","url":"/OPS102/Patterns/Online-Documentation","content":"Viewing Online Documentation To find a Linux command to perform a particular function, use theapropos or man -k commands to search the online documentation. For example, to see commands related to &quot;calendar&quot;: apropos calendar man -k calendar # same as the above! To view information about a Linux command, use the online manual (manpages), accessed with the man command: man commandname For example, to view the online manual page for cp, enter the command: man cp On Windows, you can see a list of commonly used commands by typing help To view information about a Windows command, use the online help: help commandname For example, to view the online help for dir, enter the command: help dir Alternately, to get a brief help summary for a command, enter the name of the command followed by /? -- for example, to get a help summary for the copy command, type copy /? ","keywords":"","version":"Next"},{"title":"Discretionary versus Mandatory Access Controls","type":0,"sectionRef":"#","url":"/OPS102/Permissions/DAC-vs-MAC","content":"Discretionary versus Mandatory Access Controls In multi-user operating systems it is important to be able to control access to information. This is usually done at the file and directory levels. There are two broad categories of access controls applied to files and directories: Discretionary Access Controls (DACs) - these are access controls that can be set to any value at the discretion of the users or administrators of the computer system. Mandatory Access Controls (MACs) - these are access controls that are applied across the entire system in a uniform way, and cannot be individually overridden by the users or administrators. An example of a Mandatory Access Control system is SELinux (security-enhanced Linux), a system originally developed by the National Security Agency of the US Federal Government and now part of the Linux Kernel (via KSM - Kernel Security Modules). SELinux uses type enforcementand labelling of both resources (such as files and network connections) and processes (running programs) to determine whether a specific process should have access to a specific resource, and to deny access when it does not. SELinux is used in several operating systems, including Android, Fedora, CentOS, and Red Hat Enterprise Linux. In this OPS102 course, we will be looking only at DACs.","keywords":"","version":"Next"},{"title":"Access Control Lists","type":0,"sectionRef":"#","url":"/OPS102/Permissions/ACLs","content":"Access Control Lists Windows and Linux both offer File Access Control Lists (FACLs or ACLs) to provide fine-grained control of file access. ACLs allow individual file permissions to be granted or denied to individual users and groups. However, the management of ACLs can be a complicated subject, and even experienced users sometimes misconfigure ACLs! Due to this complexity, we will not be covering ACLs in this introductory course. However, on a Windows system, basic manipulation of ACLs can be performed using the Windows Explorer file manager. Select a file which is stored on an NTFS filesystem (most internal hard disks or solid state disks, but not external drives) and right-click on it to view the file's Properties. Select the Security tab on the dialog that is displayed to view the users for which ACLs have been created, and the basic permissions that have been allowed or denied for that user on the selected file. Note that the effective permission will be a combination of the permissions allowed/denied on the file as well as on the parent directories.","keywords":"","version":"Next"},{"title":"Text Editors","type":0,"sectionRef":"#","url":"/OPS102/Patterns/Text-Editors","content":"","keywords":"","version":"Next"},{"title":"Default Text Editors​","type":1,"pageTitle":"Text Editors","url":"/OPS102/Patterns/Text-Editors#default-text-editors","content":" It is useful to learn how to use the text editor(s) provided by default with each operating system, because these editors will be available on almost any computer you use without installing any additional software. In other words, you'll be able to confidently walk up to any system, anywhere, and edit a file!  ","version":"Next","tagName":"h2"},{"title":"Linux Default Text Editor​","type":1,"pageTitle":"Text Editors","url":"/OPS102/Patterns/Text-Editors#linux-default-text-editor","content":" On Linux systems, most distributions (the organizations or companies responsible for maintaining and distributing the system) have standardized on the nano editor as the default CLI/TUI text editor (replacing the less-user-friendly but more-powerful vi editor, which was previously the default). To start nano, type nano and optionally provide a filename:  nano nano file   Nano provides a help display at the bottom of the screen. The carat ^ symbol indicates the control key, so the help text &quot;^X Exit&quot; means that you would press Ctrl-X to exit from the editor.  Since Linux systems provide multiple desktop GUI environments, the default GUI text editor(s) will vary with the installed desktop GUI. For example, on Linux desktops using the Gnome environment, the default GUI text editor is Gedit or Gnome Text Editor; on Linux desktops using the KDE desktop, the default GUI text editor is a program called Kate.  ","version":"Next","tagName":"h3"},{"title":"Windows Default Text Editor​","type":1,"pageTitle":"Text Editors","url":"/OPS102/Patterns/Text-Editors#windows-default-text-editor","content":" Previous versions of Windows included a CLI/TUI text editor called Edit. This was removed a few years ago, and Windows technical users have been asking Microsoft to reinstate it ever since. The current beta (pre-release test versions) of Windows includes a new version of Edit, and it should reappear in the main Windows releases soon.  In the interim, you can run the GUI Notepad editor, either from the Start Menu, or from the command line (as long as you are not accessing the Windows system remotely through a non-graphical connection), optionally providing a filename to be edited:  notepad notepad file   ","version":"Next","tagName":"h3"},{"title":"Other Text Editors​","type":1,"pageTitle":"Text Editors","url":"/OPS102/Patterns/Text-Editors#other-text-editors","content":" There are many other text editors available for both platforms, and many editors are available that work on multiple operating systems. For example, nano and vi are available for Windows systems, and editors similar to notepad are available on Linux.  There are also several categories of software that are (arguably) a type of text editor, including:  Basic text editorsCode editors, for editing software and configuration files, with features such as tooltip help, syntax highlighting, bracket matching, and automatic indentationWord processors, for editing documents, with features such as spell checking, visual formatting, advanced layout features such as columns and tables  Software developers and system administrators have strong opinions about their tools, and particularly about their text editors. Things to consider when selecting any type of text editor include:  Interface: does the editor use a graphical user interface, a text user interface, or can it operate in both modes?Tools: does the editor have useful tools such as syntax highlighting for common languages and configuration files? Does the list of supported languages include the ones you want to use?Visual complexity: some users prefer an editor with on-screen controls (or help) for most or all of the actions they may perform so that they can access these features quickly. Others prefer a less-cluttered screen which dedicates maximum screen space to content and minimizes distractions.Previews and integration with other tools: can the software provide visual previews, such as HTML and CSS display for web documents, LaTeX rendering, and accessibility assessments? Can you directly invoke publishing, content conversion, file transfer, or compilation processes from within the editor?Feature control: can you easily turn features on and off? For example, can you disable spell checking or syntax highlighting if your file contains a section that is in a different language? Can you disable auto-correction when it is not relevant to the project at hand?  Most software developers and system administrators use multiple editors for different tasks - for example, they may choose one editor for quick cnfiguration changes, another editor (or IDE) for larger development tasks, and multiple editors for different types of documentation.  Note that features intended for one editing task can be a nuscience in another context. For example, a word processor will often convert double quote characters into &quot;smart quotes&quot; (look closely at the quotation characters in this line), where the opening and closing quote characters are distinct characters. While these look great and are good for general writing, they are problematic in code and in examples that may appear in documentation, because they will be rejected by some types of software which expect straight double-quotes (such as most shells). ","version":"Next","tagName":"h2"},{"title":"File Redirection","type":0,"sectionRef":"#","url":"/OPS102/Redirection/File","content":"File Redirection Any of these descriptors/handles may be connected to a different file or device by adding symbols to the command line. These are the most commonly-used symbols: &gt; file redirects stdout to the specified file, overwriting any existing content, or creating the file if it does not exist &gt;&gt;file redirects stdout to the specified file, appending to existing content, or creating the file if it does not exist &lt; file redirects stdin from the specified file Both the &gt; and &gt;&gt; symbols will create the file if it does not exist. If the file does exist, the &gt; symbol will overwrite it, while the &gt;&gt; symbol will append to it (add to the end of the file). Examples on Linux: $ date &gt;now # redirect the output of the date command into the file named &quot;now&quot; $ cat now # display the file contents Tue 26 Sep 2028 01:14:02 PM EDT $ date &gt;&gt;now # append the output of the date command into the file &quot;now&quot; $ cat now # display the file contents - note that there are two dates Tue 26 Sep 2028 01:14:02 PM EDT Tue 26 Sep 2028 01:14:10 PM EDT $ date &gt;&gt;now # repeat a third time $ cat now Tue 26 Sep 2028 01:14:02 PM EDT Tue 26 Sep 2028 01:14:10 PM EDT Tue 26 Sep 2028 01:14:22 PM EDT $ date &gt;now # redirect with a single &gt; character - will overwrite $ cat now # display the file contents - note the old data was overwritten Tue 26 Sep 2028 01:14:28 PM EDT The same example on Windows: &gt; date /t &gt;now.txt &gt; type now.txt 2028-09-26 &gt; date /t &gt;&gt;now.txt &gt; type now.txt 2028-09-26 2028-09-26 &gt; date /t &gt;&gt;now.txt &gt; type now.txt 2028-09-26 2028-09-26 2028-09-26 &gt; date /t &gt;now.txt &gt; type now.txt 2023-09-26 To redirect a different file descriptior/handle, place the descriptor/handle number in front of the redirection symbol: 2&gt;file redirects stderr (2) to the specified file, overwriting 2&gt;&gt;file redirects stderr (2) to the specified file, appending Examples on Linux: $ touch one two # create the files &quot;one&quot; and &quot;two&quot; $ rm three # make sure that no file named &quot;three&quot; exists rm: cannot remove 'three': No such file or directory $ ls -l one two three # this should succeed for 2 files, fail for 1 file ls: cannot access 'three': No such file or directory -rw-r--r--. 1 chris chris 0 Sep 26 13:17 one -rw-r--r--. 1 chris chris 0 Sep 26 13:17 two $ ls -l one two three &gt;listing.txt # redirect output but not errors ls: cannot access 'three': No such file or directory $ cat listing.txt # view the saved output -rw-r--r--. 1 chris chris 0 Sep 26 13:17 one -rw-r--r--. 1 chris chris 0 Sep 26 13:17 two $ ls -l one two three &gt;listing.txt 2&gt;errors.txt # output and errors redirected separately $ cat listing.txt # view the saved output -rw-r--r--. 1 chris chris 0 Sep 26 13:17 one -rw-r--r--. 1 chris chris 0 Sep 26 13:17 two $ cat errors.txt # view the saved error messages ls: cannot access 'three': No such file or directory To redirect one descriptor/handle to another descriptor/handle, use the syntax: X&gt;&amp;Y Where X is the descriptor/handle you're redirecting, and Y is the target descriptor/handle. For example, on Linux: $ ls -l one two three &gt;all.txt 2&gt;&amp;1 # redirect stdout to all.txt, then redirect stderr to the same place as stdout $ cat all.txt # view the contents of all.txt ls: cannot access 'three': No such file or directory -rw-r--r--. 1 chris chris 0 Sep 26 13:17 one -rw-r--r--. 1 chris chris 0 Sep 26 13:17 two Note that in this example, it is necessary to redirect stdout before redirecting stderr to the same location.","keywords":"","version":"Next"},{"title":"Standard File Descriptors/Handles","type":0,"sectionRef":"#","url":"/OPS102/Redirection/Std","content":"Standard File Descriptors/Handles On Linux, other Unix-like systems, and on Windows, programs may openfile descriptors (Linux terminology) or file handles(Windows terminology). Each file descriptor/handle is a numbered channel connected to a file or device. By default, three channels are opened automatically by the shell when a process is started. These are: 0 - Standard Input (stdin) - this is the default input channel for the program 1 - Standard Output (stdout) - this is the default output channel for the program, used to output &quot;normal&quot; messages 2 - Standard Error (stderr) - this is the default error channel for the program, used to output error messages Without redirection, all three of these descriptors/handles are connected to the terminal. Therefore, the command will get input from the terminal, send output messages to the terminal, and send error messages to the terminal.","keywords":"","version":"Next"},{"title":"Piping","type":0,"sectionRef":"#","url":"/OPS102/Redirection/Piping","content":"Piping Piping is a special case of redirection, where the output (stdout) of one command is connected to the input (stdin) of another command. This is set up using the vertical-bar (pipe) symbol: | (this may look like a solid or a dashed vertical line, depending on the terminal font in use). For example, on Windows, the output of the help command is more than one screen long. You could pipe the output of the help command into the input of the more command to view one screen of text at a time: &gt; help|more For more information on a specific command, type HELP command-name ASSOC Displays or modifies file extension associations. ATTRIB Displays or changes file attributes. BREAK Sets or clears extended CTRL+C checking. BCDEDIT Sets properties in boot database to control boot loading. CACLS Displays or modifies access control lists (ACLs) of files. CALL Calls one batch program from another. CD Displays the name of or changes the current directory. CHCP Displays or sets the active code page number. CHDIR Displays the name of or changes the current directory. CHKDSK Checks a disk and displays a status report. CHKNTFS Displays or modifies the checking of disk at boot time. CLS Clears the screen. CMD Starts a new instance of the Windows command interpreter. COLOR Sets the default console foreground and background colors. COMP Compares the contents of two files or sets of files. COMPACT Displays or alters the compression of files on NTFS partitions. CONVERT Converts FAT volumes to NTFS. You cannot convert the current drive. -- More -- Press the ENTER key to scroll by one line, the spacebar to scroll by one screen, or &quot;q&quot; to quit. Similarly, on Linux, a long directory listing could be redirected tomore, or better yet, the improved less command: $ ls -l /etc | less total 2160 drwxr-xr-x. 3 root root 4096 Jun 29 20:00 abrt -rw-r--r--. 1 root root 18 May 30 03:03 adjtime -rw-r--r--. 1 root root 1529 Nov 27 2022 aliases drwxr-xr-x. 2 root root 4096 May 30 09:32 alliance drwxr-xr-x. 3 root root 4096 Sep 3 20:00 alsa drwxr-xr-x. 2 root root 4096 Aug 9 09:01 alternatives drwxr-xr-x. 4 root root 4096 Apr 13 17:47 anaconda -rw-r--r--. 1 root root 541 Jan 18 2023 anacrontab -rw-r--r--. 1 root root 269 Jan 17 2023 anthy-unicode.conf -rw-r--r--. 1 root root 833 Feb 10 2023 appstream.conf -rw-r--r--. 1 root root 55 Sep 3 20:00 asound.conf -rw-r--r--. 1 root root 1 Jan 17 2023 at.deny drwxr-x---. 4 root root 4096 Aug 5 20:00 audit drwxr-xr-x. 3 root root 4096 May 30 03:03 authselect drwxr-xr-x. 4 root root 4096 Mar 18 2023 avahi drwxr-xr-x. 2 root root 4096 May 30 09:33 avrdude drwxr-xr-x. 2 root root 4096 Aug 8 10:57 bash_completion.d -rw-r--r--. 1 root root 2638 Nov 27 2022 bashrc -rw-r--r--. 1 root root 535 Aug 6 20:00 bindresvport.blacklist drwxr-xr-x. 2 root root 4096 Sep 17 20:00 binfmt.d drwxr-xr-x. 2 root root 4096 Aug 24 20:00 bluetooth drwxr-xr-x. 2 root root 4096 May 30 09:32 bonobo-activation : Like more, you can press ENTER to scroll by one line or SPACE to scroll by one screen, or &quot;q&quot; to quit; but you can also use the up/down arrow keys, or the PgUp/PgDn keys, to scroll in either direction by one line or one screen. On Windows, to see the help lines that mention color, you could feed the output of the help command into the find command: &gt; help | find /i &quot;color&quot; COLOR Sets the default console foreground and background colors. You can accomplish complex tasks by connecting a series of simple commands together using pipes. For example, the Linux ls -l command displays permissions in the second through tenth columns of output. You could pipe the output of this command through cut and cut out just those columns: $ ls -l total 0 dr-xr-xr-x. 2 chris chris 100 Sep 26 14:22 apple -rw-r--r--. 1 chris chris 0 Sep 26 14:22 one -rw-r--r--. 1 chris chris 0 Sep 26 14:22 orange -rw-r--r--. 1 chris chris 0 Sep 26 14:22 plum -rw-r--r--. 1 chris chris 0 Sep 26 14:22 three -rw-r--r--. 1 chris chris 0 Sep 26 14:22 two $ ls -l | cut -c 2-10 otal 0 r-xr-xr-x rw-r--r-- rw-r--r-- rw-r--r-- rw-r--r-- rw-r--r-- However, this displays the &quot;total ...&quot; line at the top of the output, missing the &quot;t&quot; letter in the first column. We can eliminate this with the command tail -n +2 which will give us the last part of the output starting at line 2 (therefore skipping the first line): $ ls -l | cut -c 2-10 | tail -n +2 r-xr-xr-x rw-r--r-- rw-r--r-- rw-r--r-- rw-r--r-- rw-r--r-- If we wanted to see the filenames displayed alongside the permissions, we could take the output of ls -l, eliminate the first line (withtail as above), squeeze out multiple consecutive spaces so that they become a single space using tr -s &quot; &quot;, then use cut -d &quot; &quot; -f 1,9 to separate each line into fields delimited by the space (&quot; &quot;) character, selecting just fields 1 and 9: $ ls -l | tail -n +2 | tr -s &quot; &quot; | cut -d &quot; &quot; -f 1,9 dr-xr-xr-x. apple -rw-r--r--. one -rw-r--r--. orange -rw-r--r--. plum -rw-r--r--. three -rw-r--r--. two However, this displays an extra character in front of the file permission mode, and another extra character after the file permission mode (.), which can be eliminated by selecting the columns with anothercut command: $ ls -l | tail -n +2 | tr -s &quot; &quot; | cut -d &quot; &quot; -f 1,9 | cut -c2-10,12- r-xr-xr-x apple rw-r--r-- one rw-r--r-- orange rw-r--r-- plum rw-r--r-- three rw-r--r-- two ","keywords":"","version":"Next"},{"title":"Regular Expression Dialects","type":0,"sectionRef":"#","url":"/OPS102/regex/dialects","content":"Regular Expression Dialects Regular expressions have evolved over the years, and the various tools that handle regular expressions have different capabilities and slightly different syntax. In particular, the original Unix search tool grep came in three varieties: fgrep, which could search only for fixed text patternsgrep, which handled basic regular expressionsegrep, which handled an extended form of regular expressions The GNU project originally shipped all three commands, but fgrep and egrep were never fully standardized, so they were removed from the Posix standard in 2001. They were recently also removed from the GNU project. Unlike the original Unix grep, the GNU grep can handle the full extended regular expression syntax, in either of two ways: To use the special characters (called &quot;meta-characters&quot;) preceed them with a backslash. In other words, while a backslash makes special characters like . or ordinary, it also makes ordinary characters into special characters. Alternately, use the -E option to make grep understand extended regular expressions, which causes metacharacters to become special characters. Other tools, such as sed, similarly require backslashes in front of some of the extended regexp meta-characters (or, if you're using a GNU version of sed, you can use the -E option to enable extended regular expressions, just like GNU grep). The Perl language introduced one of the most powerful and consistent versions of the regular expression language. There has been increasing consensus around &quot;Perl-Compatible Regular Extensions&quot; (aka PCRE) and that dialect is available in many tools (including GNU grep via the -Poption, as well as the PCRE/PCRE2 library for C and C++ programs, which is used in many software packages including Safari and Apache httpd).","keywords":"","version":"Next"},{"title":"The Seven Basic Elements of Regular Expressions","type":0,"sectionRef":"#","url":"/OPS102/regex/elements","content":"","keywords":"","version":"Next"},{"title":"1. Characters​","type":1,"pageTitle":"The Seven Basic Elements of Regular Expressions","url":"/OPS102/regex/elements#1-characters","content":" In a regular expression (regexp), any character that doesn't otherwise have a special meaning matches that character. So the digit 5, for example, matches the digit 5; similarly cat matches the letters c, a, and t in sequence.  A backslash can be used to remove any special meaning which a character has. The period character . is a type of wildcard (see below), so to search for a literal period, we place a backslash in front of it: \\.  ","version":"Next","tagName":"h2"},{"title":"2. Wildcards​","type":1,"pageTitle":"The Seven Basic Elements of Regular Expressions","url":"/OPS102/regex/elements#2-wildcards","content":" A period . will match any single character. Similarly, three periods ... will match any three characters.  You can combine characters and wildcards: the regex a.e will match the letter a followed by any one character followed by the letter e. Therefore, it will match age but not app or angle.  ","version":"Next","tagName":"h2"},{"title":"3. Bracket Expressions / Character Classes​","type":1,"pageTitle":"The Seven Basic Elements of Regular Expressions","url":"/OPS102/regex/elements#3-bracket-expressions--character-classes","content":" Bracket Expressions or Character Classes are contained in square brackets [ ]  A list of characters in square brackets will match any one character from the list of characters: [abc] will match a, b, or c A range of characters in square brackets, written as a starting character, a dash, and an ending character, will match any character in that range: the regular expression [0-9] will match any one digit. There are some pre-defined named character classes. These are selected by specifying the name of the character class surrounded by colons and square brackets, placed within outer square brackets, like [[:digits:]]. The available names are: alnum - alphanumericalpha - alphabetic charactersblank - horizontal whitespace (space, tab)cntrl - control characters (text codes that don't print, such as newline, tab, and bell)digit - digitsgraph - letters, digits, and punctuationprint - letters, digits, punctuation, and spacepunct - punctuation marksspace - horizontal and vertical whitespace (space, tab, vertical tab, form feed)upper - UPPERCASE letterslower - lowercase lettersxdigit - hexidecimal digits (digits plus a-f and A-F) Ranges, lists, and named character classes may be combined - e.g., [[[:digit:]]+-.,] [[:digit:][:punct:]] [0-9_*] To invert a character class, add a carat ^ character as the first character after the opening square bracket: [^[:digit:]] matches any non-digit character, and [^:] matches any character that is not a colon. To include a literal carat, place it at the end of the character class. To include a literal dash or closing square bracket, place it at the start of the character class. Two important caveat to consider: Named character classes will match symbols from any alphabet. For example, [[:alpha:]] will match alphabetic characters from any language, and [[:digit:]] will match any digit symbols, including symbols such as ۱۲۳۴۵۶۷۸۹߀߁߂߃߄߅߆߇߈߉०१२३४५६७८९٠The &quot;collation sequence&quot; of characters determines the order of characters for sorting and comparision purposes. This may affect what is included in ranges used within bracket expressions. For example, in some collation sequences, capital letters may be interspersed between lowercase letters (aAbBcCdD...zZ), so the bracket expression [a-z] will include all of the uppercase letters except for Z. On Linux systems, the LC_COLLATE environment variable controls the collation sequence (see the manpages for locale(1), locale(5), locale(7), and charmap(5)).  ","version":"Next","tagName":"h2"},{"title":"4. Repetition​","type":1,"pageTitle":"The Seven Basic Elements of Regular Expressions","url":"/OPS102/regex/elements#4-repetition","content":" A repeat count can be placed in curly brackets. It applies to the previous element: x{3} matches xxxA repeat can be a range, written as min,max in curly brackets: x{2,5} will match xx, xxx, xxxx, or xxxxxThe maximum value in a range can be omitted: x{2,} will match two or more x characters in a rowThere are short forms for some commonly-used ranges: * is the same as {0,} (zero or more)+ is the same as {1,} (one or more)? is the same as {0,1} (zero or one)  ","version":"Next","tagName":"h2"},{"title":"5. Alternation​","type":1,"pageTitle":"The Seven Basic Elements of Regular Expressions","url":"/OPS102/regex/elements#5-alternation","content":" The vertical bar indicates alternation — either the expression on the left or the right can be matched: hot|cold will match hot or cold  ","version":"Next","tagName":"h2"},{"title":"6. Grouping​","type":1,"pageTitle":"The Seven Basic Elements of Regular Expressions","url":"/OPS102/regex/elements#6-grouping","content":" Elements placed in parenthesis are treated as a group, and can be repeated:(na)* batman will match nananana batman and nananananananana batmanGrouping may also be used to limit alternation: (fire|green)house will match firehouse or greenhouse  ","version":"Next","tagName":"h2"},{"title":"7. Anchors​","type":1,"pageTitle":"The Seven Basic Elements of Regular Expressions","url":"/OPS102/regex/elements#7-anchors","content":" Anchors match locations, not characters.A carat symbol will match the start of a line: ^[[:upper:]] will match lines that start with an uppercase letter.A dollar sign will match the end of a line: [[:punct:]]$ will match lines that end with a punctuation mark.The two anchors may be used together: cat will match the word cat anywhere on a line, but ^cat$ will only match lines that contain just the word cat and nothing else. Similarly, ^[0-9.]$ will match lines that are made up of only digits and dot characters, and ^...$ or ^.{3}$ will only match lines that contain exactly three characters. ","version":"Next","tagName":"h2"},{"title":"Linux File Permissions","type":0,"sectionRef":"#","url":"/OPS102/Permissions/Linux","content":"","keywords":"","version":"Next"},{"title":"Permission Communities​","type":1,"pageTitle":"Linux File Permissions","url":"/OPS102/Permissions/Linux#permission-communities","content":" There are three communities of users for each file:  User -- the one user that owns the file  Group -- the group of users that owns the file  Other -- every other user of the computer system  These communitities are presented in this order, so remember the sequence!: User - Group - Other (u g o)  Note that each file has both an individual user and a group owner. Thels -l command shows the user and group owner in the third and fourth columns of output.  ","version":"Next","tagName":"h2"},{"title":"Permissions​","type":1,"pageTitle":"Linux File Permissions","url":"/OPS102/Permissions/Linux#permissions","content":" Each community has three **permissions** for each file which may be individually turned on or off:  Read -- the ability to read a file.  Write -- the ability to write to the file, including permission to add to, change, or truncate (shorten) the file.  eXecute -- the ability to run (execute) a file.  Remember this sequence also!: Read - Write - eXecute (r w x)  When applied to directories, these permissions are interpreted differently:  Read -- the ability to see the names of the files and subdirectories within the directory. This is also called &quot;search&quot; permission.  Write -- the ability to create/delete/rename files and subdirectories within the directory.  eXecute (access) -- the ability to access files with the directory. If turned off, the files cannot be accessed, and metadata about each file (such as the owner, group owner, file length, permissions, and timestamps) cannot be accessed either. You can think of this as access permission when applied to directories. This is sometimes called passthroughpermission.  If execute permission is enabled for a directory but read permission has not been enabled, the affected community cannot view a directory listing to determine filenames, but if they know the name of a file within that directory, they may still access it.  If read permission is enabled for a directory but execute permission has not been enabled, the affected community can view the names of files in a directory (but only the names, not permissions, file size, ownership, or any other information), but they will have no access to use the files in any way.  However, read and execute permission are almost always assigned to a directory together.  In order to access a file, a user must have execute permission on __all__ of the directories from the root directory to the directory containing the file. For example, on the file/home/jdoe/ops102/practice/info.txt, a user must have execute permission on all four directories (home, jdoe, ops102, practice) to access the file.  ","version":"Next","tagName":"h2"},{"title":"Viewing Permissions​","type":1,"pageTitle":"Linux File Permissions","url":"/OPS102/Permissions/Linux#viewing-permissions","content":" Permissions may be viewed with the ls -l command (the ls command with the -l &quot;long detailed listing&quot; option). For example:  $ ls -l /etc/hosts -rw-r--r--. 1 root root 386 Nov 27 2022 /etc/hosts   Notice that the file's owner is &quot;root&quot;, and the file's group owner is also &quot;root&quot;.  The first character on this line is the file type (&quot;-&quot; meaning a regular file), and the next nine characters represent the three communities, each having three permissions. The permissions are written as a letter -- &quot;r&quot;, &quot;w&quot;, or &quot;x&quot; -- if the permission is enabled, or a dash &quot;-&quot; if the permission is disabled. Therefore, in the example above:  rw- the user who owns the file has read and write permission r-- the group that owns the file has read permission r-- others have read permission   Note that the user who owns the file is listed as root and the group that owns the file is listed as root -- these are not the same! The user account and group happen to have the same name in this case.  To view the permisions on a directory, you may need to specify the -doption to the ls command, which causes it to display the specified directory instead of the contents of that directory. For example:  $ ls -l / # displays the contents of the root directory total 68 dr-xr-xr-x. 2 root root 4096 Jan 18 2023 afs lrwxrwxrwx. 1 root root 7 Jan 18 2023 bin -&gt; usr/bin dr-xr-xr-x. 6 root root 4096 Sep 15 22:56 boot drwxr-xr-x. 23 root root 4860 Sep 26 10:41 dev drwxr-xr-x. 178 root root 12288 Sep 26 09:42 etc drwxr-xr-x. 5 root root 4096 May 30 14:27 home lrwxrwxrwx. 1 root root 7 Jan 18 2023 lib -&gt; usr/lib lrwxrwxrwx. 1 root root 9 Jan 18 2023 lib64 -&gt; usr/lib64 drwx------. 2 root root 16384 Apr 13 17:42 lost+found drwxr-xr-x. 2 root root 4096 Jan 18 2023 media drwxr-xr-x. 5 root root 4096 Jun 14 10:45 mnt drwxr-xr-x. 5 root root 4096 Sep 6 10:09 opt dr-xr-xr-x. 489 root root 0 Sep 26 06:26 proc dr-xr-x---. 10 root root 4096 Sep 25 05:31 root drwxr-xr-x. 56 root root 1480 Sep 26 10:28 run lrwxrwxrwx. 1 root root 8 Jan 18 2023 sbin -&gt; usr/sbin drwxr-xr-x. 2 root root 4096 Jan 18 2023 srv dr-xr-xr-x. 13 root root 0 Sep 26 10:26 sys drwxrwxrwt. 25 root root 580 Sep 26 10:51 tmp drwxr-xr-x. 13 root root 4096 May 30 09:33 usr drwxr-xr-x. 21 root root 4096 May 30 12:46 var $ ls -l -d / # displays the root directory itself dr-xr-xr-x. 19 root root 4096 Sep 4 15:05 /   You can also view permissions as an octal number using the stat command - note the value marked &quot;Access&quot;:  $ stat /etc/hosts File: /etc/hosts Size: 386 Blocks: 8 IO Block: 4096 regular file Device: 253,0 Inode: 4194708 Links: 1 Access: (0644/-rw-r\\--r\\--) Uid: ( 0/ root) Gid: ( 0/ root) Context: system_u:object_r:net_conf_t:s0 Access: 2024-01-23 16:29:33.807860342 -0500 Modify: 2022-11-27 10:26:24.000000000 -0500 Change: 2023-05-30 03:00:51.739043061 -0400 Birth: 2023-05-30 03:00:51.738043061 -0400   ","version":"Next","tagName":"h2"},{"title":"Setting Permissions​","type":1,"pageTitle":"Linux File Permissions","url":"/OPS102/Permissions/Linux#setting-permissions","content":" The permissions on a file are also called the permission mode of the file, so the command to change the permissions is called chmod(&quot;change mode&quot;).  The chmod command can be used in either of two ways: with symbolic or numeric permissions.  In either case, the command accepts the mode as the first positional argument, and the filename(s) (or patterns) as the remaining positional arguments:  chmod mode filename...   ","version":"Next","tagName":"h2"},{"title":"Using Symbolic Mode​","type":1,"pageTitle":"Linux File Permissions","url":"/OPS102/Permissions/Linux#using-symbolic-mode","content":" Symbolic mode represents permissions as a list of one or more communities, represented by a letter:  u (user) g (group) o (other) a (all - a short form to specify ugo)   This is followed by an action symbol:  + (add permissions) - (remove permissions) = (set permissions)   The difference between +/- and = is that +/- will add or remove the specified permissions while leaving other permissions unchanged, while = will explicitly set the permissions to exactly the value specified.  This is followed by zero or more of these letters, representing permissions:  r (read)`\\ w (write)`\\ x (execute - note that this is lowercase)`\\ X (execute if applied to a directory, or nothing if applied to a file -- note that this is UPPERCASE)   Therefore the symbolic notation g+rx instructs chmod to add read and execute permission to the group community, and a-w instructs chmod to remote write permission from all of the communities (user, group, and other).  Here is an example:  $ touch test001 # create a file for testing $ ls -l test001 # show the current permissions -rw-r--r--. 1 chris chris 0 Sep 26 11:20 test001 $ chmod g+w test001 # to group, add (+) write permission $ ls -l test001 -rw-rw-r--. 1 chris chris 0 Sep 26 11:20 test001 $ chmod o-r test001 # to other, remove (-) read permission $ ls -l test001 -rw-rw----. 1 chris chris 0 Sep 26 11:20 test001 $ chmod u=rw,go= test001 # set user to have only read and write, group and other to have nothing $ ls -l test001 -rw-------. 1 chris chris 0 Sep 26 11:20 test001   And another example using a directory:  $ mkdir apple # create a directory for testing $ touch apple/honeycrisp # create some files in that directory $ touch apple/gala $ touch apple/ambrosia $ ls -l -d apple # see the permissions on the directory drwxr-xr-x. 2 chris chris 100 Sep 26 11:26 apple $ ls -l apple # see the files total 0 -rw-r--r--. 1 chris chris 0 Sep 26 11:26 ambrosia -rw-r--r--. 1 chris chris 0 Sep 26 11:25 gala -rw-r--r--. 1 chris chris 0 Sep 26 11:25 honeycrisp $ chmod a=rx apple # set permission (for all) to read and execute only $ ls -l -d apple dr-xr-xr-x. 2 chris chris 100 Sep 26 11:26 apple $ ls -l apple # note that we can still see inside the directory total 0 -rw-r--r--. 1 chris chris 0 Sep 26 11:26 ambrosia -rw-r--r--. 1 chris chris 0 Sep 26 11:25 gala -rw-r--r--. 1 chris chris 0 Sep 26 11:25 honeycrisp $ touch apple/macintosh # we cannot create a file in the directory touch: cannot touch 'apple/macintosh': Permission denied $ mv apple/gala apple/fuji # we cannot rename a file mv: cannot move 'apple/gala' to 'apple/fuji': Permission denied $ rm apple/gala # we cannot remove a file rm: cannot remove 'apple/gala': Permission denied $ chmod a=r apple # set permission to read only $ ls -l -d apple dr--r--r--. 2 chris chris 100 Sep 26 11:26 apple $ ls -l apple # we can see the filenames (r) but not the details (x) ls: cannot access 'apple/ambrosia': Permission denied ls: cannot access 'apple/gala': Permission denied ls: cannot access 'apple/honeycrisp': Permission denied total 0 -????????? ? ? ? ? ? ambrosia -????????? ? ? ? ? ? gala -????????? ? ? ? ? ? honeycrisp $ cat apple/ambrosia # we cannot access any files in that directory (x) cat: apple/ambrosia: Permission denied $ chmod a=x apple # set permission to execute (passthrough) only $ ls -l -d apple d--x--x--x. 2 chris chris 100 Sep 26 11:26 apple $ ls -l apple # we cannot see the list of files in that directory ls: cannot open directory 'apple': Permission denied $ ls -l apple/gala # however, if we know the exact name of the file, we can view it -rw-r--r--. 1 chris chris 0 Sep 26 11:25 apple/gala   ","version":"Next","tagName":"h3"},{"title":"Using Numeric Mode​","type":1,"pageTitle":"Linux File Permissions","url":"/OPS102/Permissions/Linux#using-numeric-mode","content":" You can also specify a mode using a number. Each digit has a range of 0 to 7, so these are known as octal (base eight) numbers. An extra zero is often written in front of the number to indicate that the number is in octal.  When a numeric value is used to specify the permission mode, all of the permissions for all of the communities must be set at the same time. You cannot add or remove some permissions, or set permission for just some of the communities, as you can with symbolic mode.  The digits are written from left-to-right in the order of the communities (u g o), with each digit being the sum of the granted permission according to these values:  4 read 2 write 1 execute   Examples:  rwx would have a value of 7 (4+2+1) rw- would have a value of 6 (4+2) r-- would have a value of 4 (4)   Therefore these permissions are equivalent:  rwxrw-r-- 0764 rwxrwxrwx 0777 rw-r--r-- 0744 rwx--x--x 0711   Here are some examples of chmod commands with numeric modes:  $ touch example001 $ ls -l example001 -rw-r--r--. 1 chris chris 0 Sep 26 11:45 example001 $ chmod 0111 example001 $ ls -l example001 ---x--x--x. 1 chris chris 0 Sep 26 11:45 example001 $ chmod 0764 example001 $ ls -l example001 -rwxrw-r--. 1 chris chris 0 Sep 26 11:45 example001 $ chmod 0640 example001 $ ls -l example001 -rw-r-----. 1 chris chris 0 Sep 26 11:45 example001   ","version":"Next","tagName":"h3"},{"title":"Recursively Setting Permissions​","type":1,"pageTitle":"Linux File Permissions","url":"/OPS102/Permissions/Linux#recursively-setting-permissions","content":" It is sometimes useful to use the chmod -R option to recursively set all the permissions on a directory and all of its contents. However, it is quite common to need to set execute permissions on directories but not on files. You can indicate this to chmod using a capital X for the execute permission.  # Don't do this! It will set Execute permission on files and directories. chmod -R go+rx publicdir # Instead, do this to set Execute permission on directories only (not files): # (Notice the capital X in the symbolic permissions) chmod -R go+rX publicdir   ","version":"Next","tagName":"h3"},{"title":"Other useful chmod Options​","type":1,"pageTitle":"Linux File Permissions","url":"/OPS102/Permissions/Linux#other-useful-chmod-options","content":" -v Verbose: show information about each file processed (changed or not) -c Changes: show information about each change made (only changed files)   ","version":"Next","tagName":"h3"},{"title":"Controlling Permissions on New Files and Directories​","type":1,"pageTitle":"Linux File Permissions","url":"/OPS102/Permissions/Linux#controlling-permissions-on-new-files-and-directories","content":" There is a setting known as umask which controls the permissions assigned to new files and directories. The umask value is a numeric mode which represents the permissions which are not permitted on new files.  The actual permission which is given to new files is a combination of two values:  The mode requested by the software creating the file (using the open, openat, or creat system calls), except for The modes prohibited by the umask value.  For example, a umask value of 0022 represents the permissions----w--w- (write permission for group and other). Therefore, any new files or directories will be created without these permissions. This is the default permission on Matrix.  The umask value can be viewed or set with the umask command.  For example, the touch command requests 0666 (rw-rw-rw-) permission on new files. Here is a demo of how the umask value can change the assigned permissions:  $ umask # view the current umask 0022 $ touch testfile0022 # umask of 0022 will deny write for group and other $ ls -l testfile0022 -rw-r--r--. 1 chris chris 0 Sep 26 11:54 testfile0022 $ umask 0000 # umask of 0000 will not deny any permissions $ touch testfile0000 $ ls -l testfile0000 -rw-rw-rw-. 1 chris chris 0 Sep 26 11:54 testfile0000 $ umask 0027 # deny group write, plus all permissions for other $ touch testfile0027 $ ls -l testfile0027 -rw-r-----. 1 chris chris 0 Sep 26 11:55 testfile0027   To ensure that no one else has any access to new files and directories that you create on Matrix (unless you change the permission mode of the file after it is created), set your umask to 0077: umask 0077  Note that the umask value is specific to the process that is currently running, and it inherited by child processes. That means that if you're using multiple shells (perhaps in multiple windows), each shell's umask value is specific to that shell, and changing it will not affect the other active shells. However, any command or program that you run from that shell will inherit the umask value. You can set the default umask value for all future bash sessions by placing a umask command into your~/.bashrc file.  Warning: be extremely careful editing your~/.bashrc file, since an error may prevent you from logging in to your Matrix account. Always stay logged in to Matrix on one terminal while using a second terminal to confirm that you are able to successfully log in to the system. If you are not able to login, fix the problem using the first terminal and then re-test.  ","version":"Next","tagName":"h2"},{"title":"Special Permissions​","type":1,"pageTitle":"Linux File Permissions","url":"/OPS102/Permissions/Linux#special-permissions","content":" (Note that this is an advanced topic - these permissions are not used on the majority of files).  There are three additional, &quot;special&quot; permissions:  Set User ID (SUID) - when applied to an executable program file, this permission changes the effective user ID from the user executing the file to the owner of the file for the duration of the process. For example, if a user *jdoe* executes the *passwd* command (which is owned by the *root* user and has the Set User ID permission enabled), the effective user ID is temporarily changed to *root* while that command is executing. This enables the *passwd* command to change the user's password in the */etc/shadow* file, which they otherwise do not have access to.  Set Group ID (SGID) - when applied to an executable program file, this permission is similar to SUID, but it changes the effective group ID instead of the effective user ID. When applied to a directory, this causes all newly-created files and directories with that directory to be owned by the same group that owns the directory. For example, if the directory */var/www/html/* is owned by the group *website*, then any file or directory created within */var/www/html/* will automatically be owned by the group *website* instead of the group of the person creating the file.  Sticky bit (t) - when applied to a directory, any file within that directory may be renamed or deleted only by the owner of the file, by the owner of the directory, or by a privileged process (for example, *root*, the master system administrator), regardless of any other permissions that might be set. The system's temporary directoriers (*/tmp* and */var/tmp*) have this turned on.  These permissions are represented in the ls -l output as modifications of the 'x' character:  SUID changes the user\\'s x character to an s (or S if eXecute is not turned on) SGID changes the group\\'s x character to an s (or S if eXecute is not turned on) The sticky bit changes other\\'s x character to a t (or T if the eXecute is not turned on)   When using symbolic modes with chmod, the permissions are requested as follows:  SUID is &quot;s&quot; permission in the &quot;u&quot; community SGID is &quot;s&quot; permission in the &quot;g&quot; community Sticky is &quot;t&quot; permission in the &quot;o&quot; community  When using numeric modes with chmod, these special permissions are represented as an additional octal digit to the left of the three basic octal permission digits. The value of these special permissions is:  4 SUID 2 SGID 1 Sticky   Examples:  $ cp /usr/bin/cp mycp # make a private copy of the 'cp' command $ ls -l mycp # view the original permissions -rwxr-xr-x. 1 chris chris 145488 Sep 26 12:21 mycp $ chmod u+s mycp # add SUID $ ls -l mycp # view the new permissions -rwsr-xr-x. 1 chris chris 145488 Sep 26 12:21 mycp $ cp /usr/bin/mv mymv # make a private copy of the 'mv' command $ ls -l mymv # view the original permissions -rwxr-xr-x. 1 chris chris 137280 Sep 26 12:21 mymv $ chmod 06755 mymv # turn on SUID and SGID and set permissions to rwxr-xr-x $ ls -l mymv # view the new permissions -rwsr-sr-x. 1 chris chris 137280 Sep 26 12:21 mymv $ ls -l -d /usr/bin/passwd /tmp # view some existing files with special permissions drwxrwxrwt. 26 root root 600 Sep 26 12:21 /tmp -rwsr-xr-x. 1 root root 32760 Jan 18 2023 /usr/bin/passwd   ","version":"Next","tagName":"h2"},{"title":"Securing Your Account​","type":1,"pageTitle":"Linux File Permissions","url":"/OPS102/Permissions/Linux#securing-your-account","content":" There are two ways to secure your account on Matrix:  1. If you do not want to share any of your files with other users, you can disable access to your home directory by turning off all permissions for the group and other communities. The command chmod go= ~ will set this. Since this turns off access permission to that directory, other users will not be able to access any of the files within your home directory, regardless of the permission on the individual file.  2. If you want to share access to some of your files with other users, turn on the appropriate permissions for group and/or other users, and use the umask to limit the permissions on new files and directories.  For example, you might:  Start by turning off all permissions on the files and directories that are currently in your home directory:  chmod -r go= ~/*   Create a directory of files you wish to share, called *~/public*. Set the permission on this directory so that group and others can access it:  mkdir ~/public chmod go=rx ~/public   Place any files that you want to share in the *~/public* directory and set appropriate permissions:  cp anyFilesYouWantToShare ~/public chmod go=r ~/public   Set up you umask so that, by default, other users have no access to any new files you create (place this in your *~/.bashrc* file to ensure that it is applied to all new bash shells that you start in the future):  umask 0077   Ensure that users can access your ~/public directory through your home directory:  chmod go=rx ~`\\  ","version":"Next","tagName":"h2"},{"title":"Regular Expression Examples","type":0,"sectionRef":"#","url":"/OPS102/regex/examples","content":"Regular Expression Examples Description\tRegexp (GNU Extended Grep dialect - &quot;grep -E&quot; or &quot;egrep&quot;)\tMatches these lines\tDoes not match these lines\tCommentsA specific word\tHello\tHello Hello there! Hello, World! He said, &quot;Hello James&quot;, in a very threatening tone\tHi there Hell of a Day h el lo\tThis will match &quot;Hello&quot; anywhere on the line, but not permit any variations, such as spaces in the word or UPPER-/lower-case changes. A specific word with nothing else on the line\t^Hello$\tHello\tHello there! Hello, World! He said, &quot;Hello James&quot;, in a very threatening tone Hi there Hell of a Day h el lo 5-character line\t^.....$\trouge green Ho-ho\tYellow long line tiny 12-45-78\tThe anchor characters prevent extra characters from existing between the five characters and the start and end of the line. Lines that start with a vowel\t^[AEIOUYaeiouy]\tAllo Everything Energy Under Yellow everything\tHello White 4164915050 Grinch\tThe character class includes both UPPERCASE and lowercase letters. You could instead use the option (specific to the tool you're using) to ignore case; for example, ''-i'' for grep or ''/I'' for findstr. Lines that end in a punctuation mark\t[[:punct:]]$\tHello there! Thanks. What do you think?\tHello there 416-491-5050 New Year greetings Lines where the 3rd character is the letter &quot;J&quot;\t^..J\tS J 94723 N J 244325 N3J 2R6\tJKLM Just Kidding\tThis pattern is anchored to the front of the line, and maches any characters in the first two positions followed by the letter 'J' (uppercase only) in the third position. Lines that have fields separated by colons, where the third field is the number with four or more digits.\t^[^:]*:[^:]*:[[:digit:]]{4,}:\tjdoe:x:1007:1000:J. Doe:/home/jdoe:/usr/bin/bash rdoe:x:12425:1000:R. Doe:/home/rdoe:/usr/bin/bash\thttpd:x:80:80:Apache HTTP server:/dev/null:/bin/false\tThe pattern [^:]* will match zero or more characters that are not colons, or in other words, the contents of one field. If you use this pattern to search the Linux file /etc/passwd, you should see only regular user accounts, since system accounts have user IDs (in the third field) that are three digits or less. An integer\t^[-+]?[[:digit:]]+$\t+15 -2 720 1440 1280 1920 000 012\t+ 4 3.14 0x47 $1.13 $4 123,456\tThis looks for lines that start with a + or - (optional), then contain digits. A decimal number\t^[-+]?[[:digit:]]+\\.?[[:digit:]]*$\t+3.14 42 -1000.0 +212 +36.7 42.00 3.333333333 0.976\t.976 +-200 1.1.1.1 13.4.7\tThis will match lines that start with + or - (optional), then contain digits, then optionally contain a decimal point followed by zero or more additional digits. A Canadian Postal Code\t^[ABCEGHJKLMNPRSTVXY][0-9][ABCEGHJKLMNPRSTVWXYZ] ?[0-9][ABCEGHJKLMNPRSTVWXYZ][0-9]$\tH0H 0H0 M3C 1L2 K1A 0A2 T2G 0P3 V8W 9W2 R3B 0N2 M2J2X5 M5S 2C6\tPOB 1L0 90210 MN4 2R6\tA Canadian postal code alternates between letters and digits: A9A 9A9. The first letter must be one of ABCEGHJKLMNPRSTVXY and the remaining letters must be one of ABCEGHJKLMNPRSTVXY. Phone Numbers (Canada/US)\t^[^+[:digit:]]*(\\+?1)?[^+[:digit:]]*[[2-9]]([^+[:digit:]]*[[0-9]]){9}[^+[:digit:]]*$\t(416) 967-1111 +1 416-736-3636 416-439-0000\t+65 6896 2391 555-1212\tA Canadian/US phone number consists of a 3-digit Area Code (which may not start with 0 or 1) and a 10-digit local number consisting of an exchange (3 digits) and a line (4 digits). The country code for Canada and the US is 1, so the number may be preceeded by +1 or 1. Area codes are sometimes contained in parenthesis, and dashes or spaces are sometimes used as separators. IP Address (IPv4 dotted quad)\t`^((25[0-5]\t2[0-4][0-9]\t1[0-9][0-9]\t[1-9][0-9] Private IP Address\t`^(10.(25[0-5]\t2[0-4][0-9]\t1[0-9][0-9]\t[1-9][0-9]","keywords":"","version":"Next"},{"title":"Windows findstr and Regular Expressions","type":0,"sectionRef":"#","url":"/OPS102/regex/findstr","content":"Windows findstr and Regular Expressions The Windows findstr command accepts regular expressions or literal expressions. It will guess what you're using, and may guess incorrectly, so it's best to use the /R and /L options to directly specify if your search pattern is a regexp or literal. Findstr permits multiple search patterns in a quoted string, separated by a space; this acts like a type of alternation. However, this makes it impossible to use a literal space in a search pattern. If you wish to include a space in your search pattern, prepend /C: to your search string. You can use multiple /C: search strings. For example, FINDSTR /R /C:&quot;red&quot; /C:&quot;blue&quot; INPUTFILE is roughly equivalent to grep -E &quot;red|blue&quot; INPUTFILE Findstr is also limited to (approximately) 127 characters in the regular expression. For information on findstr's regular expression dialect, see help findstr. In particular, the findstr command does not support: alternation with the | symbolrepetition other than with the * symbolnamed character classes [[:*name*:]]grouping ( )","keywords":"","version":"Next"},{"title":"Using Regular Expressions","type":0,"sectionRef":"#","url":"/OPS102/regex/using","content":"Using Regular Expressions Regular expressions can be used in many places, including: Linux GNU grepThe bash test command [[ &quot;string&quot; =~ regexp ]] Note that the regular expression is not quotedIf you need to use a space in your regular expression, store the regex in a variable and use the variable as the regex argument in the command.Example: X=&quot;ABC&quot;; if [[ &quot;$X&quot; =~ ^[[:upper:]]{3}$ ]]; then echo &quot;MATCH&quot; ; else echo &quot;NO MATCH&quot; ; fi The less command, using the / and ? keystrokes for searching forward and backwardThe vi/vim editor, also using the / and ? keystrokes for searching forward and backwardThe sed and awk utilities Windows findstr /R (see notes below)Many PowerShell commands Programming Languages (Cross-Platform) Cross-platform Shells (Powershell, zsh, bash)PythonJavaScriptPerlC / C++ via PCRE/PCRE2 library\\...and many others!","keywords":"","version":"Next"},{"title":"What are Regular Expressions?","type":0,"sectionRef":"#","url":"/OPS102/regex/what-why","content":"","keywords":"","version":"Next"},{"title":"Why should we use Regular Expressions?​","type":1,"pageTitle":"What are Regular Expressions?","url":"/OPS102/regex/what-why#why-should-we-use-regular-expressions","content":" Regular Expressions (regexp or regex) can be a little daunting to learn: they often look like someone was just bashing their head against the keyboard (or, like a cat was walking across the keyboard). But they are very powerful: a well-written regular expression can replace many pages of code in a programming language such as C or C++, and so it is worth investing some time to understand them. ","version":"Next","tagName":"h2"},{"title":"Computer Resources","type":0,"sectionRef":"#","url":"/OPS102/Resources_and_Processes/Resources","content":"","keywords":"","version":"Next"},{"title":"Processes​","type":1,"pageTitle":"Computer Resources","url":"/OPS102/Resources_and_Processes/Resources#processes","content":" On a multitasking computer system, a process is a single instance of an executing computer program. For example, ssh is one program. If there are no running instances of ssh on a computer system, then there are no ssh processes. If one user starts one ssh session, then one there is one ssh process. If five users start a combined total of twelve ssh sessions, then there are twelve ssh processes.  Each process is assigned a Process ID (PID) and is allocated its own resources, such as memory. Processes are scheduled to run (execute) on a CPU core for a fraction of a second, and then the operating system may intervene and switch the CPU core to run another processes. However, if a process is waiting for an I/O resources, such as data from a storage device, a packet of data from the network, or a keystroke from the user, it may inform the operating system that it does not need to be executed until that resource is available. A process which is ineligible for execution because it is waiting for a resources is called a sleepingprocess.  ","version":"Next","tagName":"h2"},{"title":"Resource Conflicts​","type":1,"pageTitle":"Computer Resources","url":"/OPS102/Resources_and_Processes/Resources#resource-conflicts","content":" When the resource requirements of running computer programs significantly exceed available resources, system performance will become unsatisfactory.  It is important to be able to identify the resource consumption of each process, and each operating system provides multiple tools to do this. They also provide tools to terminate processes if they are unstable or consuming excessive resources.  ","version":"Next","tagName":"h2"},{"title":"Challenges with Monitoring Resource Usage​","type":1,"pageTitle":"Computer Resources","url":"/OPS102/Resources_and_Processes/Resources#challenges-with-monitoring-resource-usage","content":" It is difficult to accurately monitor a process' resource utilization because it will change from microsecond to microsecond. In addition, some resources are very difficult to accurately measure:  ","version":"Next","tagName":"h2"},{"title":"Memory​","type":1,"pageTitle":"Computer Resources","url":"/OPS102/Resources_and_Processes/Resources#memory","content":" On contemporary computer systems, memory is very actively and dynamically managed by the Operating System using the hardware's virtual memory features. This enables many useful techniques, including:  Demand Loading - Only the portion of programs which are used are loaded. Code for features that are not used is not loaded into memory. For example, in a word processor (such as LibreOffice/OpenOffice or Word), features such as table of content generation, endnotes, and watermarks are not used in many documents, and the code for those features will not be loaded in many cases.Sharing of Memory - Shared libraries (also called Dynamically Linked Libraries) may be used by many different processes. These libraries are loaded into memory only once, using demand loading, regardless of the number of processes using each library. Similarly, a program which is running in two or more processes will be loaded into memory only once, and shared between the processes. This significantly reduces memory requirements.Swap - When system memory (RAM) is approaching full utilization, the operating system may take some of the least-recently-used areas of memory and place them in storage (hard disk or solid state disk) or compress them in order to avoid running out of free memory. Areas of memory swapped out may be swapped back in if they are later required.  Due to the utilization of these techniques and others, the memory consumption of a program can be calculated in many different ways. For example:  You could add up the full size of the program, all of the shared libraries, and the data used by a process, but that would yield a large number (a pessimistic view of memory consumption). The process is likely not occupying that much memory, and terminating the process will typically release only a fraction of that memory because most of the shared libraries will still be loaded into memory and in use by other programs.You could add up just the portion of the program in memory plus the data area in memory used by a process, but this would understate the full memory utilization because it does not include the shared libraries nor the portion of the program or data which has been swapped out or which has not (yet) been demand-loaded.  Therefore resource monitoring tools may present several different statistics about memory usage for each process, or may try to present a rough approximation of the amount of total system memory which can be reasonably attributed to a process.  ","version":"Next","tagName":"h3"},{"title":"CPU​","type":1,"pageTitle":"Computer Resources","url":"/OPS102/Resources_and_Processes/Resources#cpu","content":" Each CPU core is independently capable of executing programs. Most modern CPUs have multiple cores (Symmetric Multi Processing, SMP), enabling multiple programs to be executed simultaneously. Many modern CPUs can execute more than one thread on a core (Symmetric Multi Threading, SMT), meaning that they have hardware support for rapid switching between two or more processes (or, in some cases, sub-processes called threads) on one core -- so a 4-core CPU may be marketed as capable of running up to 8 tasks. However, this does not mean that 8 programs can be fully executed at once!  To use an analogy, a SMP processor is a bit like an apartment building, where each core is like an apartment and can fully accommodate a family (whether a single, couple, roommates, or parents and children), or, in the case of the CPU, fully execute a process. SMT capability is a bit like Airbnb rentals, which enable those units to be shared out quickly when they're not in use by the main occupants, or in the case of the CPU, quickly run other threads when the core (or part of the core) is not in use.  Further complicating the issue is the fact that CPUs may have multiple cores of different specifications -- some fast, power-hungry cores used for heavy tasks, and other slower, energy-efficient cores for lighter tasks. Cores may be shut down and started up by the OS as needed. For example, some Seneca lab computers have an Intel CPU with 12 cores consisting of 10 performance cores (capable of running 2 threads) and 2 efficiency cores (capable of running 1 thread). In a similar way, a Google Pixel 8 phone has 4 energy-efficient/low-performance Arm Cortex-A510 cores, 4 mid-range Cortex-A715 cores, and one high-energy-usage/very high-performance Cortex-X3 core.  In addition, current CPUs can operate at a range of speeds, and the OS and hardware work together to dynamically tune the speed to balance temperature, energy usage, and performance.  Therefore, statistics reporting the percentage of CPU capability in use by a process may report the percentage of a core's capability in use, either with or without considering SMT capabilities, or they may report the percentage of the full CPU's capability (including all cores). When cores of different specifications are part of a single CPU, it may be difficult to determine the relative ratio of performance between the different types of cores, especially as the speed of those cores is being adjusted -- and therefore utilization percentages are almost always a rough approximation. ","version":"Next","tagName":"h3"},{"title":"Table of contents","type":0,"sectionRef":"#","url":"/OPS102/toc","content":"","keywords":"","version":"Next"},{"title":"1. Introduction to Operating Systems​","type":1,"pageTitle":"Table of contents","url":"/OPS102/toc#1-introduction-to-operating-systems","content":" What is an Operating System?What does an Operating System do?Components of an Operating SystemGraphical User Interfaces vs Command Line InterfacesA Brief History of Operating SystemsAnatomy of a Command Line Interface (CLI)  ","version":"Next","tagName":"h2"},{"title":"2. Filesystem Basics​","type":1,"pageTitle":"Table of contents","url":"/OPS102/toc#2-filesystem-basics","content":" Hierarchical File SystemsFilenamesCurrent Working DirectoryPathnamesVolume DesignatorsBasic Commands for Dealing with Files and Directories  ","version":"Next","tagName":"h2"},{"title":"3. Filename Patterns, Common Commands, and Text Editors​","type":1,"pageTitle":"Table of contents","url":"/OPS102/toc#3-filename-patterns-common-commands-and-text-editors","content":" Filename PatternsCommon CommandsViewing Online DocumentationText Editors  ","version":"Next","tagName":"h2"},{"title":"4. Permissions​","type":1,"pageTitle":"Table of contents","url":"/OPS102/toc#4-permissions","content":" Discretionary vs. Mandatory Access ControlsLinux File PermissionsAccess Control Lists  ","version":"Next","tagName":"h2"},{"title":"5. Redirection​","type":1,"pageTitle":"Table of contents","url":"/OPS102/toc#5-redirection","content":" Standard File Descriptors/HandlesFile RedirectionPiping  ","version":"Next","tagName":"h2"},{"title":"6. Resources and Processes​","type":1,"pageTitle":"Table of contents","url":"/OPS102/toc#6-resources-and-processes","content":" Computer ResourcesMonitoring and Terminating Processes  ","version":"Next","tagName":"h2"},{"title":"7. Bash Scripting​","type":1,"pageTitle":"Table of contents","url":"/OPS102/toc#7-bash-scripting","content":" What is a Script?Basic Requirements for Shell ScriptsCommentsVariablesEnvironment VariablesReading Values from Stdin: readCommand CaptureArithmeticExit Status CodesConditional Logic: if / then / elif / else / fiThe test CommandParametersExample ScriptsLooping in Bash  ","version":"Next","tagName":"h2"},{"title":"8. Windows CMD Scripting​","type":1,"pageTitle":"Table of contents","url":"/OPS102/toc#8-windows-cmd-scripting","content":" Windows vs. Linux ScriptingBasic Requirements for Shell ScriptsCommand EchosBasic Script ExampleVariablesEnvironment VariablesReading Values from Stdin: set /pConditional Logic: if/elseScript ParamterrsLooping  ","version":"Next","tagName":"h2"},{"title":"9. Regular Expressions​","type":1,"pageTitle":"Table of contents","url":"/OPS102/toc#9-regular-expressions","content":" What are Regular Expressions? Why use them?The Seven Basic Elements of Regular ExpressionsRegular Expression ExamplesRegular Expression DialectsUsing Regular ExpressionsWindows FINDSTR and Regular Expressions ","version":"Next","tagName":"h2"},{"title":"Monitoring and Terminating Processes","type":0,"sectionRef":"#","url":"/OPS102/Resources_and_Processes/Processes","content":"","keywords":"","version":"Next"},{"title":"Monitoring and Terminating Processes on Windows​","type":1,"pageTitle":"Monitoring and Terminating Processes","url":"/OPS102/Resources_and_Processes/Processes#monitoring-and-terminating-processes-on-windows","content":" ","version":"Next","tagName":"h2"},{"title":"Graphical User Interface​","type":1,"pageTitle":"Monitoring and Terminating Processes","url":"/OPS102/Resources_and_Processes/Processes#graphical-user-interface","content":" To manage processes graphically on Windows, use the Task Managertool. You can access this from the Start menu, or by pressing Ctrl-Alt-Delete and selecting Task Manager from the menu that appears.  The Task Manager display shows processes grouped by executable name, along with approximate resource usage.  To terminate a process, select it using the mouse, and then click on the End Task button in the lower-right corner of the display.  ","version":"Next","tagName":"h3"},{"title":"Command Line Interface using the CMD Shell​","type":1,"pageTitle":"Monitoring and Terminating Processes","url":"/OPS102/Resources_and_Processes/Processes#command-line-interface-using-the-cmd-shell","content":" To manage processes using the CMD shell (the default shell on Windows), use these commands:  1. **tasklist** - displays a list of tasks (processes) active on the system. You can use options to select which processes are displayed, as well as the output format (table, list, or comma-separated values).  2. **taskkill** - terminates a process. By default, this command attempts to get tasks to terminate in a safe manner (for example, if the program is saving a file, that operation will be completed before the program terminates). If a program does not respond to request, you can specify the /f option, which forcibly terminates the program.  You can specify the process to be terminated in one of two ways:  By process ID, using the */PID nnn* option, which will terminate the process with the specified process ID.By image (program or library) name, using the */IM name* option, which terminates processes with the given image name. Asterisk wildcard characters may be specified as part of the name. Names must include the extension (for example, use *taskkill /im firefox.exe* or *taskkill /im firefox** instead of *taskkill /im firefox*).  The tasklist and taskkill commands also provide a mechanism for filtering the process selection; see the online documentation for details (help tasklist or help taskkill).  ","version":"Next","tagName":"h3"},{"title":"Command Line Interface using Powershell​","type":1,"pageTitle":"Monitoring and Terminating Processes","url":"/OPS102/Resources_and_Processes/Processes#command-line-interface-using-powershell","content":" Powershell is an alternate Windows shell. You can use these commands to view and terminate processes using Powershell:  1. **get-process** - Displays a list of current processes with basic information about each. You can specify a program name as a positional argument (without the filename extension); see the online documentation for other available options.  2. **stop-process** - Terminates a process. You may specify a PID using the -ID option (stop-process -id pid) or a program name (without the filename extension) using the -NAME option (stop-process -name name).  Tip - Short Names:** Many Powershell commandlets (built-in commands) have short names. The short name for the get-processcommand is ps and the short name for the stop-processcommand is kill, which conveniently match the names of similar commands on Linux!  ","version":"Next","tagName":"h3"},{"title":"Monitoring and Terminating Processes on Linux​","type":1,"pageTitle":"Monitoring and Terminating Processes","url":"/OPS102/Resources_and_Processes/Processes#monitoring-and-terminating-processes-on-linux","content":" ","version":"Next","tagName":"h2"},{"title":"Command Line Interface​","type":1,"pageTitle":"Monitoring and Terminating Processes","url":"/OPS102/Resources_and_Processes/Processes#command-line-interface","content":" From the bash (default shell) command line on Linux, you can view the current process table using the process status command ps. By default, it will show only processes associated with the current shell, and will show only the process ID (PID), terminal, total execution time, and command name:   $ ps PID TTY TIME CMD 303632 pts/4 00:00:00 bash 303771 pts/4 00:00:00 ps   There are many ps options available to control which processes are displayed and what information is displayed about each process. These are the more commonly-used:   -u user - Displays all processes owned by user -e - Shows every process -l - Shows long output, including process status (S), process ID (PID), parent process ID (PPID), approximate memory size (SZ), total execution time (TIME), and program name (CMD) -f - Shows full output, including process ID (PID), parent process ID (PPID), process start time (STIME), total execution time (TIME), and program name (CMD)   To terminate a process on Linux, send it a signal using the killcommand. Processes are specified by ID:   kill PID   By default, processes are send the terminate signal (signal 15, SIGTERM). This requests that the process terminate gracefully (for example, by completing pending operations before stopping). If a program does not respond to this signal, the kill signal (signal 9, SIGKILL) may be specified; this signal tells the operating system to abruptly and forcefully terminate the process. Either of these forms is accepted:   kill -9 PID kill -KILL PID   There are many other signals that may be sent to processes; to see a list of all available signals, run the command kill -l or see the online documentation for signal(7) (by running the command: man 7 signal).  To find all processes associated with a given program, use the pgrep command: pgrep name  To terminate processes by program name, use the killall command:killall name  ","version":"Next","tagName":"h3"},{"title":"Text User Interface​","type":1,"pageTitle":"Monitoring and Terminating Processes","url":"/OPS102/Resources_and_Processes/Processes#text-user-interface","content":" In addition to the command-line interface (CLI) tools mentioned above, there are several text user interface (TUI) tools available which display a full-screen view of the current process status which is updated periodically.  The most common TUI process monitoring tool is top, which displays output like this:   top - 11:51:05 up 1 day, 22:23, 2 users, load average: 0.63, 0.62, 0.66 Tasks: 530 total, 1 running, 529 sleeping, 0 stopped, 0 zombie %Cpu(s): 1.2 us, 1.4 sy, 0.0 ni, 97.1 id, 0.0 wa, 0.2 hi, 0.1 si, 0.0 st MiB Mem : 28797.0 total, 730.7 free, 17121.8 used, 10944.4 buff/cache MiB Swap: 8192.0 total, 8188.0 free, 4.0 used. 10960.2 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 299042 qemu 20 0 11.4g 8.2g 30336 S 18.5 29.2 23:06.23 qemu-system-x86 2382 chris 20 0 1313576 201884 78048 S 2.6 0.7 11:56.51 Xorg 7037 chris 20 0 33.0g 562524 275008 S 2.6 1.9 24:20.54 chrome 2654 chris 20 0 6512860 298252 136624 S 2.3 1.0 16:25.62 gnome-shell 304806 chris 20 0 1005964 54372 40312 S 2.3 0.2 1:00.46 gnome-system-mo 8265 chris 20 0 851044 64084 39280 S 1.0 0.2 14:41.79 gnome-terminal- 1111 polkitd 20 0 603836 12488 7528 S 0.7 0.0 3:37.71 polkitd 7089 chris 20 0 33.0g 324364 171304 S 0.7 1.1 5:50.08 chrome 7354 chris 20 0 1134.3g 355716 129476 S 0.7 1.2 6:32.51 chrome 296095 chris 20 0 1132.2g 160168 115772 S 0.7 0.5 1:14.49 chrome 299134 qemu 20 0 11.0g 2.9g 27264 S 0.7 10.2 1:25.34 qemu-system-x86 1 root 20 0 217576 28572 10624 S 0.3 0.1 0:54.85 systemd 1118 root 20 0 15232 7552 6784 S 0.3 0.0 0:25.38 systemd-machine 2823 root 20 0 249680 19604 8064 S 0.3 0.1 7:15.86 sssd_kcm 2955 chris 20 0 684472 17024 14720 S 0.3 0.1 9:13.72 gsd-smartcard 3340 root 20 0 542844 13952 11776 S 0.3 0.0 0:04.69 abrt-dbus 7090 chris 20 0 32.6g 155276 108568 S 0.3 0.5 13:29.98 chrome 7363 chris 20 0 1132.3g 335376 120948 S 0.3 1.1 3:16.12 chrome 295131 chris 20 0 1136.3g 426468 132800 S 0.3 1.4 3:13.88 chrome 311918 chris 20 0 225500 4224 3072 R 0.3 0.0 0:00.21 top 2 root 20 0 0 0 0 S 0.0 0.0 0:00.20 kthreadd 3 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 rcu_gp 4 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 rcu_par_gp 5 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 slub_flushwq   This display is sorted by processor utilization (shown in the %CPU column); you can change the sort order to memory utilization (%MEM) by pressing Shift-M, and change back to processor utilization by pressing Shift-P.  By default, this display is updated every 3 seconds; you can change the update frequency by pressing S and typing a new update frequency (in seconds between updates).  To terminate a process, press K; the program will prompt you for the process ID to be killed (defaulting to the one at the top of the display, using the most resources), and the signal to be sent to that process (defaulting to signal 15, SIGTERM).  To see help messages about available options, press the ? key.  To exit from top, press the Q key (quit).  The top command is available on most Linux and Unix-like systems, including matrix.senecacollege.ca. There are several newer commands available, including htop and btop, but these are not present on all systems.  ","version":"Next","tagName":"h2"},{"title":"Graphical User Interface​","type":1,"pageTitle":"Monitoring and Terminating Processes","url":"/OPS102/Resources_and_Processes/Processes#graphical-user-interface-1","content":" If you're using a GUI on a Linux system, many graphical process monitoring and control tools are available, including the Gnome System Monitorand Conky. ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}